/-
This is a Lean formalization of a negative answer to Erdos Problem 189.
https://www.erdosproblems.com/189

The final statement was available from the Formal Conjectures project,
though it required a small correction.

Statement from Erdos Problems:
If $\mathbb{R}^2$ is finitely coloured then must there exist some colour class which contains the vertices of a rectangle of every area?

Clean statement:
It is possible to partition $\mathbb{R}^2$ into $25$ color classes such that none of them contains the vertices of a rectangle of area $1$.

The original human proof was published in the paper
V. Kovač, Coloring and density theorems for configurations of a given volume, preprint (2024), arXiv:2309.09973.

LaTeX blueprint of the proof prepared by V. Kovač
https://web.math.pmf.unizg.hr/~vjekovac/EP/EP189/Erdos189_blueprint.tex
was auto-formalized into Lean by Aristotle (Harmonic).

The rest of the file was generated by Aristotle on 2025-12-17.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: fb33bd98-547f-4f7a-880d-3890941f0827
-/

/-
We prove that it is possible to partition the complex plane (identified with $\mathbb{R}^2$) into 25 color classes such that no color class contains the vertices of a rectangle of area 1. We construct such a coloring explicitly based on the fractional parts of the real and imaginary parts of $\frac{3}{2}z^2$.
-/

import Mathlib

namespace Erdos189


set_option linter.mathlibStandardSet false

open scoped BigOperators

open scoped Real

open scoped Nat

open scoped Classical

open scoped Pointwise

set_option maxHeartbeats 0

set_option maxRecDepth 4000

set_option synthInstance.maxHeartbeats 20000

set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false

set_option autoImplicit false

noncomputable section

open Complex

#check GaussianInt

#check Int.floor

#check Int.toNat

#check Int.emod_nonneg

#check Int.emod_lt_of_pos

/-
A set of complex numbers forms a rectangle of area 1 if it consists of 4 distinct points $z_1, z_2, z_3, z_4$ such that $z_2 - z_1 = z_3 - z_4$ (parallelogram), $(z_2 - z_1) \cdot \overline{(z_4 - z_1)}$ has real part 0 (perpendicular sides), and $|z_2 - z_1|^2 |z_4 - z_1|^2 = 1$ (area squared is 1).
-/
open Complex

def IsRectangleArea1 (s : Set ℂ) : Prop :=
  ∃ z1 z2 z3 z4, s = {z1, z2, z3, z4} ∧ z1 ≠ z2 ∧ z1 ≠ z3 ∧ z1 ≠ z4 ∧ z2 ≠ z3 ∧ z2 ≠ z4 ∧ z3 ≠ z4 ∧
  (z2 - z1 = z3 - z4) ∧ ((z2 - z1) * star (z4 - z1)).re = 0 ∧ normSq (z2 - z1) * normSq (z4 - z1) = 1

/-
The color tuple of a complex number $z$ is a pair of integers modulo 5, derived from the floor of the real and imaginary parts of $\frac{3}{2}z^2$.
-/
open Complex

def color_tuple (z : ℂ) : Fin 5 × Fin 5 :=
  let u := (3/2 : ℂ) * z^2
  (⟨(Int.floor u.re).emod 5 |>.toNat, by
    -- Since the floor function returns an integer, and modulo 5 gives a remainder between 0 and 4, this should hold.
    have h_mod : (Int.floor u.re).emod 5 < 5 := by
      exact Int.emod_lt_of_pos _ ( by decide );
    grind⟩,
   ⟨(Int.floor u.im).emod 5 |>.toNat, by
     -- Since $⌊u.im⌋ \% 5$ is the remainder when $⌊u.im⌋$ is divided by 5, it must be less than 5.
     have h_mod : ⌊u.im⌋ % 5 < 5 := by
       exact Int.emod_lt_of_pos _ ( by norm_num )
     exact (by
     linarith! [ Int.toNat_of_nonneg ( Int.emod_nonneg ( ⌊u.im⌋ ) ( by decide : ( 5 : ℤ ) ≠ 0 ) ) ])⟩)

/-
The coloring function maps a complex number $z$ to a color in $\{0, \dots, 24\}$ based on its color tuple $(j, k)$ via the formula $5j + k$.
-/
open Complex

def color (z : ℂ) : Fin 25 :=
  let (j, k) := color_tuple z
  ⟨5 * j.val + k.val, by
    have hj := j.isLt
    have hk := k.isLt
    calc
      5 * j.val + k.val ≤ 5 * 4 + 4 := by gcongr; apply Nat.le_of_lt_succ hj; apply Nat.le_of_lt_succ hk
      _ = 24 := by norm_num
      _ < 25 := by norm_num⟩

/-
It is possible to partition $\mathbb{R}^2$ into $25$ color classes such that none of them contains the vertices of a rectangle of area $1$.
-/
open Complex

theorem partition_rectangles : ∃ (f : ℂ → Fin 25), ∀ (c : Fin 25), ¬ ∃ (s : Set ℂ), s ⊆ f ⁻¹' {c} ∧ IsRectangleArea1 s := by
  use color
  intro c_color
  rintro ⟨s, hs_sub, hs_rect⟩
  obtain ⟨z1, z2, z3, z4, h_s, h_ne1, h_ne2, h_ne3, h_ne4, h_ne5, h_ne6, h_par, h_perp, h_area⟩ := hs_rect
  have h_col : color z1 = color z2 ∧ color z2 = color z3 ∧ color z3 = color z4 := by
    simp only [Set.subset_def, Set.mem_preimage, Set.mem_singleton_iff] at hs_sub
    rw [h_s] at hs_sub
    have h1 : color z1 = c_color := hs_sub z1 (by simp)
    have h2 : color z2 = c_color := hs_sub z2 (by simp)
    have h3 : color z3 = c_color := hs_sub z3 (by simp)
    have h4 : color z4 = c_color := hs_sub z4 (by simp)
    simp [h1, h2, h3, h4]
  bound;
  rw [ Set.subset_def ] at hs_sub;
  have := hs_sub z1 ( by norm_num ) ; have := hs_sub z2 ( by norm_num ) ; have := hs_sub z3 ( by norm_num ) ; have := hs_sub z4 ( by norm_num ) ; simp_all +decide [ color ] ;
  have h_monochrome : Int.floor ((3 / 2 : ℝ) * (z1 ^ 2).re) % 5 = Int.floor ((3 / 2 : ℝ) * (z2 ^ 2).re) % 5 ∧ Int.floor ((3 / 2 : ℝ) * (z1 ^ 2).im) % 5 = Int.floor ((3 / 2 : ℝ) * (z2 ^ 2).im) % 5 ∧ Int.floor ((3 / 2 : ℝ) * (z1 ^ 2).re) % 5 = Int.floor ((3 / 2 : ℝ) * (z3 ^ 2).re) % 5 ∧ Int.floor ((3 / 2 : ℝ) * (z1 ^ 2).im) % 5 = Int.floor ((3 / 2 : ℝ) * (z3 ^ 2).im) % 5 ∧ Int.floor ((3 / 2 : ℝ) * (z1 ^ 2).re) % 5 = Int.floor ((3 / 2 : ℝ) * (z4 ^ 2).re) % 5 ∧ Int.floor ((3 / 2 : ℝ) * (z1 ^ 2).im) % 5 = Int.floor ((3 / 2 : ℝ) * (z4 ^ 2).im) % 5 := by
    unfold color_tuple at *;
    simp +zetaDelta at *;
    have h_mod_eq : ∀ x : ℤ, x % 5 = (x.emod 5).toNat := by
      exact fun x => by erw [ Int.toNat_of_nonneg ( Int.emod_nonneg _ ( by decide ) ) ] ;
    grind;
  -- Let $I = z_1^2 - z_2^2 + z_3^2 - z_4^2$. We show that $|I| = 2$ for any rectangle of area 1.
  set I : ℂ := z1^2 - z2^2 + z3^2 - z4^2
  have h_I : Complex.normSq I = 4 := by
    norm_num [ Complex.normSq ] at *;
    rw [ sub_eq_iff_eq_add ] at h_par ; aesop;
    norm_num [ sq ] at * ; nlinarith;
  -- We also show that if $z_1, z_2, z_3, z_4$ are monochromatic, then $I$ must lie in a region that is disjoint from the circle $|w|=2$.
  have h_I_disjoint : ∃ k1 k2 : ℤ, Complex.re I = (k1 : ℝ) * (10 / 3) + (Complex.re I - (k1 : ℝ) * (10 / 3)) ∧ Complex.im I = (k2 : ℝ) * (10 / 3) + (Complex.im I - (k2 : ℝ) * (10 / 3)) ∧ |Complex.re I - (k1 : ℝ) * (10 / 3)| < 4 / 3 ∧ |Complex.im I - (k2 : ℝ) * (10 / 3)| < 4 / 3 := by
    -- Since $z_1, z_2, z_3, z_4$ are monochromatic, we have $⌊(3 / 2 : ℝ) * (z1 ^ 2).re⌋ ≡ ⌊(3 / 2 : ℝ) * (z2 ^ 2).re⌋ ≡ ⌊(3 / 2 : ℝ) * (z3 ^ 2).re⌋ ≡ ⌊(3 / 2 : ℝ) * (z4 ^ 2).re⌋ \pmod{5}$ and similarly for the imaginary parts.
    obtain ⟨k1, hk1⟩ : ∃ k1 : ℤ, ⌊(3 / 2 : ℝ) * (z1 ^ 2).re⌋ - ⌊(3 / 2 : ℝ) * (z2 ^ 2).re⌋ + ⌊(3 / 2 : ℝ) * (z3 ^ 2).re⌋ - ⌊(3 / 2 : ℝ) * (z4 ^ 2).re⌋ = 5 * k1 := by
      exact Int.dvd_of_emod_eq_zero ( by omega )
    obtain ⟨k2, hk2⟩ : ∃ k2 : ℤ, ⌊(3 / 2 : ℝ) * (z1 ^ 2).im⌋ - ⌊(3 / 2 : ℝ) * (z2 ^ 2).im⌋ + ⌊(3 / 2 : ℝ) * (z3 ^ 2).im⌋ - ⌊(3 / 2 : ℝ) * (z4 ^ 2).im⌋ = 5 * k2 := by
      exact Int.dvd_of_emod_eq_zero ( by omega );
    refine' ⟨ k1, k2, _, _, _, _ ⟩ <;> norm_num [ abs_lt ];
    · simp +zetaDelta at *;
      constructor <;> linarith [ Int.floor_le ( ( 3 : ℝ ) / 2 * ( z1 ^ 2 |> Complex.re ) ), Int.lt_floor_add_one ( ( 3 : ℝ ) / 2 * ( z1 ^ 2 |> Complex.re ) ), Int.floor_le ( ( 3 : ℝ ) / 2 * ( z2 ^ 2 |> Complex.re ) ), Int.lt_floor_add_one ( ( 3 : ℝ ) / 2 * ( z2 ^ 2 |> Complex.re ) ), Int.floor_le ( ( 3 : ℝ ) / 2 * ( z3 ^ 2 |> Complex.re ) ), Int.lt_floor_add_one ( ( 3 : ℝ ) / 2 * ( z3 ^ 2 |> Complex.re ) ), Int.floor_le ( ( 3 : ℝ ) / 2 * ( z4 ^ 2 |> Complex.re ) ), Int.lt_floor_add_one ( ( 3 : ℝ ) / 2 * ( z4 ^ 2 |> Complex.re ) ), ( by norm_cast : ( ⌊ ( 3 : ℝ ) / 2 * ( z1 ^ 2 |> Complex.re ) ⌋ : ℝ ) - ⌊ ( 3 : ℝ ) / 2 * ( z2 ^ 2 |> Complex.re ) ⌋ + ⌊ ( 3 : ℝ ) / 2 * ( z3 ^ 2 |> Complex.re ) ⌋ - ⌊ ( 3 : ℝ ) / 2 * ( z4 ^ 2 |> Complex.re ) ⌋ = 5 * k1 ) ];
    · norm_num +zetaDelta at *;
      constructor <;> linarith [ Int.floor_le ( ( 3 : ℝ ) / 2 * ( z1 ^ 2 |> Complex.im ) ), Int.lt_floor_add_one ( ( 3 : ℝ ) / 2 * ( z1 ^ 2 |> Complex.im ) ), Int.floor_le ( ( 3 : ℝ ) / 2 * ( z2 ^ 2 |> Complex.im ) ), Int.lt_floor_add_one ( ( 3 : ℝ ) / 2 * ( z2 ^ 2 |> Complex.im ) ), Int.floor_le ( ( 3 : ℝ ) / 2 * ( z3 ^ 2 |> Complex.im ) ), Int.lt_floor_add_one ( ( 3 : ℝ ) / 2 * ( z3 ^ 2 |> Complex.im ) ), Int.floor_le ( ( 3 : ℝ ) / 2 * ( z4 ^ 2 |> Complex.im ) ), Int.lt_floor_add_one ( ( 3 : ℝ ) / 2 * ( z4 ^ 2 |> Complex.im ) ), ( by norm_cast : ( ⌊ ( 3 : ℝ ) / 2 * ( z1 ^ 2 |> Complex.im ) ⌋ : ℝ ) - ⌊ ( 3 : ℝ ) / 2 * ( z2 ^ 2 |> Complex.im ) ⌋ + ⌊ ( 3 : ℝ ) / 2 * ( z3 ^ 2 |> Complex.im ) ⌋ - ⌊ ( 3 : ℝ ) / 2 * ( z4 ^ 2 |> Complex.im ) ⌋ = 5 * k2 ) ];
  obtain ⟨ k1, k2, hk1, hk2, hk3, hk4 ⟩ := h_I_disjoint;
  norm_num [ Complex.normSq ] at *;
  rcases k1 with ⟨ _ | _ | k1 ⟩ <;> norm_num at hk3 <;> try nlinarith only [ abs_lt.mp hk3, abs_lt.mp hk4, h_I ] ;
  rcases k2 with ⟨ _ | _ | k2 ⟩ <;> norm_num at hk4 <;> nlinarith only [ abs_lt.mp hk3, abs_lt.mp hk4, h_I ] ;

/-
If $z_1, z_2, z_3, z_4$ form a rectangle of area 1, then $|z_1^2 - z_2^2 + z_3^2 - z_4^2|^2 = 4$.
-/
open Complex

lemma rectangle_imp_abs_I_eq_two {z1 z2 z3 z4 : ℂ}
  (h_par : z2 - z1 = z3 - z4)
  (h_perp : ((z2 - z1) * star (z4 - z1)).re = 0)
  (h_area : normSq (z2 - z1) * normSq (z4 - z1) = 1) :
  normSq (z1^2 - z2^2 + z3^2 - z4^2) = 4 := by
  -- Let $u = z_2 - z_1$ and $v = z_4 - z_1$.
  set u : ℂ := z2 - z1
  set v : ℂ := z4 - z1;
  -- So the vertices are $z_1, z_1+u, z_1+u+v, z_1+v$.
  have h_vertices : z2 = z1 + u ∧ z3 = z1 + u + v ∧ z4 = z1 + v := by
    grind +ring;
  rw [ h_vertices.1, h_vertices.2.1, h_vertices.2.2 ] ; ring;
  norm_num [ Complex.normSq_mul ] at * ; linarith

/-
If $z_1, z_2, z_3, z_4$ are monochromatic, then the real and imaginary parts of $I = z_1^2 - z_2^2 + z_3^2 - z_4^2$ are close to multiples of $10/3$.
-/
open Complex

lemma monochromatic_imp_I_close {z1 z2 z3 z4 : ℂ}
  (h_col : color z1 = color z2 ∧ color z2 = color z3 ∧ color z3 = color z4) :
  ∃ k1 k2 : ℤ,
    let I := z1^2 - z2^2 + z3^2 - z4^2
    abs (I.re - (k1 : ℝ) * (10 / 3)) < 4 / 3 ∧
    abs (I.im - (k2 : ℝ) * (10 / 3)) < 4 / 3 := by
  -- Let $n_j = \lfloor \frac{3}{2} \text{Re}(z_j^2) \rfloor$. Then $n_1 - n_2 + n_3 - n_4$ is divisible by 5.
  have h_n_div : ∃ k1 k2 : ℤ,
      let n1 := ⌊(3/2 : ℝ) * (z1 ^ 2).re⌋
      let n2 := ⌊(3/2 : ℝ) * (z2 ^ 2).re⌋
      let n3 := ⌊(3/2 : ℝ) * (z3 ^ 2).re⌋
      let n4 := ⌊(3/2 : ℝ) * (z4 ^ 2).re⌋
      n1 - n2 + n3 - n4 = 5 * k1 ∧
      let m1 := ⌊(3/2 : ℝ) * (z1 ^ 2).im⌋
      let m2 := ⌊(3/2 : ℝ) * (z2 ^ 2).im⌋
      let m3 := ⌊(3/2 : ℝ) * (z3 ^ 2).im⌋
      let m4 := ⌊(3/2 : ℝ) * (z4 ^ 2).im⌋
      m1 - m2 + m3 - m4 = 5 * k2 := by
        -- By definition of color, we know that the real and imaginary parts of $z^2$ are congruent modulo 5.
        have h_cong : ⌊(3/2 : ℝ) * (z1 ^ 2).re⌋ % 5 = ⌊(3/2 : ℝ) * (z2 ^ 2).re⌋ % 5 ∧ ⌊(3/2 : ℝ) * (z2 ^ 2).re⌋ % 5 = ⌊(3/2 : ℝ) * (z3 ^ 2).re⌋ % 5 ∧ ⌊(3/2 : ℝ) * (z3 ^ 2).re⌋ % 5 = ⌊(3/2 : ℝ) * (z4 ^ 2).re⌋ % 5 ∧ ⌊(3/2 : ℝ) * (z1 ^ 2).im⌋ % 5 = ⌊(3/2 : ℝ) * (z2 ^ 2).im⌋ % 5 ∧ ⌊(3/2 : ℝ) * (z2 ^ 2).im⌋ % 5 = ⌊(3/2 : ℝ) * (z3 ^ 2).im⌋ % 5 ∧ ⌊(3/2 : ℝ) * (z3 ^ 2).im⌋ % 5 = ⌊(3/2 : ℝ) * (z4 ^ 2).im⌋ % 5 := by
          unfold color at h_col;
          unfold color_tuple at h_col; norm_num at h_col;
          -- By definition of color, we know that the real and imaginary parts of $z^2$ are congruent modulo 5 for each $z_i$.
          have h_cong : ∀ z : ℂ, ⌊(3 / 2 : ℝ) * (z ^ 2).re⌋ % 5 = (⌊(3 / 2 : ℝ) * (z ^ 2).re⌋.emod 5).toNat ∧ ⌊(3 / 2 : ℝ) * (z ^ 2).im⌋ % 5 = (⌊(3 / 2 : ℝ) * (z ^ 2).im⌋.emod 5).toNat := by
            exact fun z => ⟨ Eq.symm ( Int.toNat_of_nonneg ( Int.emod_nonneg _ ( by norm_num ) ) ), Eq.symm ( Int.toNat_of_nonneg ( Int.emod_nonneg _ ( by norm_num ) ) ) ⟩;
          grind;
        exact ⟨ ( ⌊3 / 2 * ( z1 ^ 2 |> Complex.re ) ⌋ - ⌊3 / 2 * ( z2 ^ 2 |> Complex.re ) ⌋ + ⌊3 / 2 * ( z3 ^ 2 |> Complex.re ) ⌋ - ⌊3 / 2 * ( z4 ^ 2 |> Complex.re ) ⌋ ) / 5, ( ⌊3 / 2 * ( z1 ^ 2 |> Complex.im ) ⌋ - ⌊3 / 2 * ( z2 ^ 2 |> Complex.im ) ⌋ + ⌊3 / 2 * ( z3 ^ 2 |> Complex.im ) ⌋ - ⌊3 / 2 * ( z4 ^ 2 |> Complex.im ) ⌋ ) / 5, by omega, by omega ⟩;
  norm_num [ Complex.ext_iff, sq ] at * ; aesop;
  · use w; rw [ abs_lt ] ; constructor <;> push_cast [ ← @Int.cast_inj ℝ .. ] at * <;> linarith [ Int.floor_le ( 3 / 2 * ( z1.re * z1.re - z1.im * z1.im ) ), Int.lt_floor_add_one ( 3 / 2 * ( z1.re * z1.re - z1.im * z1.im ) ), Int.floor_le ( 3 / 2 * ( z2.re * z2.re - z2.im * z2.im ) ), Int.lt_floor_add_one ( 3 / 2 * ( z2.re * z2.re - z2.im * z2.im ) ), Int.floor_le ( 3 / 2 * ( z3.re * z3.re - z3.im * z3.im ) ), Int.lt_floor_add_one ( 3 / 2 * ( z3.re * z3.re - z3.im * z3.im ) ), Int.floor_le ( 3 / 2 * ( z4.re * z4.re - z4.im * z4.im ) ), Int.lt_floor_add_one ( 3 / 2 * ( z4.re * z4.re - z4.im * z4.im ) ) ] ;
  · refine' ⟨ w_1, abs_lt.mpr ⟨ _, _ ⟩ ⟩ <;> push_cast [ ← @Int.cast_inj ℝ .. ] at * <;> linarith [ Int.floor_le ( 3 / 2 * ( z1.re * z1.im + z1.im * z1.re ) ), Int.lt_floor_add_one ( 3 / 2 * ( z1.re * z1.im + z1.im * z1.re ) ), Int.floor_le ( 3 / 2 * ( z2.re * z2.im + z2.im * z2.re ) ), Int.lt_floor_add_one ( 3 / 2 * ( z2.re * z2.im + z2.im * z2.re ) ), Int.floor_le ( 3 / 2 * ( z3.re * z3.im + z3.im * z3.re ) ), Int.lt_floor_add_one ( 3 / 2 * ( z3.re * z3.im + z3.im * z3.re ) ), Int.floor_le ( 3 / 2 * ( z4.re * z4.im + z4.im * z4.re ) ), Int.lt_floor_add_one ( 3 / 2 * ( z4.re * z4.im + z4.im * z4.re ) ) ]

/-
There is no complex number $I$ with $|I|^2 = 4$ that is close to a point in the lattice $\frac{10}{3}(\mathbb{Z} + i\mathbb{Z})$.
-/
open Complex

lemma no_I_on_circle (I : ℂ) (k1 k2 : ℤ)
  (h_abs : normSq I = 4)
  (h_close_re : abs (I.re - (k1 : ℝ) * (10 / 3)) < 4 / 3)
  (h_close_im : abs (I.im - (k2 : ℝ) * (10 / 3)) < 4 / 3) :
  False := by
  rcases k1 with ⟨ _ | _ | k1 ⟩ <;> norm_num at * <;> try nlinarith [ abs_lt.mp h_close_re, abs_lt.mp h_close_im, Complex.normSq_apply I ] ;
  rcases k2 with ⟨ _ | _ | k2 ⟩ <;> norm_num [ Complex.normSq_apply ] at * <;> nlinarith [ abs_lt.mp h_close_re, abs_lt.mp h_close_im ]

/-
It is possible to partition $\mathbb{R}^2$ into $25$ color classes such that none of them contains the vertices of a rectangle of area $1$.
-/
open Complex

theorem partition_rectangles_final : ∃ (f : ℂ → Fin 25), ∀ (c : Fin 25), ¬ ∃ (s : Set ℂ), s ⊆ f ⁻¹' {c} ∧ IsRectangleArea1 s := by
  use color
  intro c_color
  rintro ⟨s, hs_sub, hs_rect⟩
  obtain ⟨z1, z2, z3, z4, h_s, h_ne1, h_ne2, h_ne3, h_ne4, h_ne5, h_ne6, h_par, h_perp, h_area⟩ := hs_rect
  have h_col : color z1 = color z2 ∧ color z2 = color z3 ∧ color z3 = color z4 := by
    simp only [Set.subset_def, Set.mem_preimage, Set.mem_singleton_iff] at hs_sub
    rw [h_s] at hs_sub
    have h1 : color z1 = c_color := hs_sub z1 (by simp)
    have h2 : color z2 = c_color := hs_sub z2 (by simp)
    have h3 : color z3 = c_color := hs_sub z3 (by simp)
    have h4 : color z4 = c_color := hs_sub z4 (by simp)
    simp [h1, h2, h3, h4]
  let I := z1^2 - z2^2 + z3^2 - z4^2
  have h_abs : normSq I = 4 := rectangle_imp_abs_I_eq_two h_par h_perp h_area
  have h_close : ∃ k1 k2 : ℤ, abs (I.re - (k1 : ℝ) * (10 / 3)) < 4 / 3 ∧ abs (I.im - (k2 : ℝ) * (10 / 3)) < 4 / 3 := monochromatic_imp_I_close h_col
  obtain ⟨k1, k2, hk1, hk2⟩ := h_close
  exact no_I_on_circle I k1 k2 h_abs hk1 hk2

/-
If $z_1, z_2, z_3, z_4$ form a rectangle of area 1, then $|z_1^2 - z_2^2 + z_3^2 - z_4^2|^2 = 4$.
-/
open Complex

lemma rectangle_imp_abs_I_eq_two_proved {z1 z2 z3 z4 : ℂ}
  (h_par : z2 - z1 = z3 - z4)
  (h_perp : ((z2 - z1) * star (z4 - z1)).re = 0)
  (h_area : normSq (z2 - z1) * normSq (z4 - z1) = 1) :
  normSq (z1^2 - z2^2 + z3^2 - z4^2) = 4 := by
    convert rectangle_imp_abs_I_eq_two h_par h_perp h_area using 1

/-
It is possible to partition $\mathbb{R}^2$ into $25$ color classes such that none of them contains the vertices of a rectangle of area $1$.
-/
open Complex

theorem partition_rectangles_final_v2 : ∃ (f : ℂ → Fin 25), ∀ (c : Fin 25), ¬ ∃ (s : Set ℂ), s ⊆ f ⁻¹' {c} ∧ IsRectangleArea1 s := by
  use color
  intro c_color
  rintro ⟨s, hs_sub, hs_rect⟩
  obtain ⟨z1, z2, z3, z4, h_s, h_ne1, h_ne2, h_ne3, h_ne4, h_ne5, h_ne6, h_par, h_perp, h_area⟩ := hs_rect
  have h_col : color z1 = color z2 ∧ color z2 = color z3 ∧ color z3 = color z4 := by
    simp only [Set.subset_def, Set.mem_preimage, Set.mem_singleton_iff] at hs_sub
    rw [h_s] at hs_sub
    have h1 : color z1 = c_color := hs_sub z1 (by simp)
    have h2 : color z2 = c_color := hs_sub z2 (by simp)
    have h3 : color z3 = c_color := hs_sub z3 (by simp)
    have h4 : color z4 = c_color := hs_sub z4 (by simp)
    simp [h1, h2, h3, h4]
  let I := z1^2 - z2^2 + z3^2 - z4^2
  have h_abs : normSq I = 4 := rectangle_imp_abs_I_eq_two_proved h_par h_perp h_area
  have h_close : ∃ k1 k2 : ℤ, abs (I.re - (k1 : ℝ) * (10 / 3)) < 4 / 3 ∧ abs (I.im - (k2 : ℝ) * (10 / 3)) < 4 / 3 := monochromatic_imp_I_close h_col
  obtain ⟨k1, k2, hk1, hk2⟩ := h_close
  exact no_I_on_circle I k1 k2 h_abs hk1 hk2

/-
It is possible to partition $\mathbb{R}^2$ into $25$ color classes such that none of them contains the vertices of a rectangle of area $1$.
-/
open Complex

theorem partition_rectangles_final_v3 : ∃ (f : ℂ → Fin 25), ∀ (c : Fin 25), ¬ ∃ (s : Set ℂ), s ⊆ f ⁻¹' {c} ∧ IsRectangleArea1 s := by
  use color
  intro c_color
  rintro ⟨s, hs_sub, hs_rect⟩
  obtain ⟨z1, z2, z3, z4, h_s, h_ne1, h_ne2, h_ne3, h_ne4, h_ne5, h_ne6, h_par, h_perp, h_area⟩ := hs_rect
  have h_col : color z1 = color z2 ∧ color z2 = color z3 ∧ color z3 = color z4 := by
    simp only [Set.subset_def, Set.mem_preimage, Set.mem_singleton_iff] at hs_sub
    rw [h_s] at hs_sub
    have h1 : color z1 = c_color := hs_sub z1 (by simp)
    have h2 : color z2 = c_color := hs_sub z2 (by simp)
    have h3 : color z3 = c_color := hs_sub z3 (by simp)
    have h4 : color z4 = c_color := hs_sub z4 (by simp)
    simp [h1, h2, h3, h4]
  let I := z1^2 - z2^2 + z3^2 - z4^2
  have h_abs : normSq I = 4 := rectangle_imp_abs_I_eq_two_proved h_par h_perp h_area
  have h_close : ∃ k1 k2 : ℤ, abs (I.re - (k1 : ℝ) * (10 / 3)) < 4 / 3 ∧ abs (I.im - (k2 : ℝ) * (10 / 3)) < 4 / 3 := monochromatic_imp_I_close h_col
  obtain ⟨k1, k2, hk1, hk2⟩ := h_close
  exact no_I_on_circle I k1 k2 h_abs hk1 hk2

/-
It is possible to partition $\mathbb{R}^2$ into $25$ color classes such that none of them contains the vertices of a rectangle of area $1$.
-/
open Complex

theorem partition_rectangles_main : ∃ (f : ℂ → Fin 25), ∀ (c : Fin 25), ¬ ∃ (s : Set ℂ), s ⊆ f ⁻¹' {c} ∧ IsRectangleArea1 s := by
  use color
  intro c_color
  rintro ⟨s, hs_sub, hs_rect⟩
  obtain ⟨z1, z2, z3, z4, h_s, h_ne1, h_ne2, h_ne3, h_ne4, h_ne5, h_ne6, h_par, h_perp, h_area⟩ := hs_rect
  have h_col : color z1 = color z2 ∧ color z2 = color z3 ∧ color z3 = color z4 := by
    simp only [Set.subset_def, Set.mem_preimage, Set.mem_singleton_iff] at hs_sub
    rw [h_s] at hs_sub
    have h1 : color z1 = c_color := hs_sub z1 (by simp)
    have h2 : color z2 = c_color := hs_sub z2 (by simp)
    have h3 : color z3 = c_color := hs_sub z3 (by simp)
    have h4 : color z4 = c_color := hs_sub z4 (by simp)
    simp [h1, h2, h3, h4]
  let I := z1^2 - z2^2 + z3^2 - z4^2
  have h_abs : normSq I = 4 := rectangle_imp_abs_I_eq_two_proved h_par h_perp h_area
  have h_close : ∃ k1 k2 : ℤ, abs (I.re - (k1 : ℝ) * (10 / 3)) < 4 / 3 ∧ abs (I.im - (k2 : ℝ) * (10 / 3)) < 4 / 3 := monochromatic_imp_I_close h_col
  obtain ⟨k1, k2, hk1, hk2⟩ := h_close
  exact no_I_on_circle I k1 k2 h_abs hk1 hk2

/-
It is possible to partition $\mathbb{R}^2$ into $25$ color classes such that none of them contains the vertices of a rectangle of area $1$.
-/
open Complex

theorem partition_rectangles_final_v4 : ∃ (f : ℂ → Fin 25), ∀ (c : Fin 25), ¬ ∃ (s : Set ℂ), s ⊆ f ⁻¹' {c} ∧ IsRectangleArea1 s := by
  use color
  intro c_color
  rintro ⟨s, hs_sub, hs_rect⟩
  obtain ⟨z1, z2, z3, z4, h_s, h_ne1, h_ne2, h_ne3, h_ne4, h_ne5, h_ne6, h_par, h_perp, h_area⟩ := hs_rect
  have h_col : color z1 = color z2 ∧ color z2 = color z3 ∧ color z3 = color z4 := by
    simp only [Set.subset_def, Set.mem_preimage, Set.mem_singleton_iff] at hs_sub
    rw [h_s] at hs_sub
    have h1 : color z1 = c_color := hs_sub z1 (by simp)
    have h2 : color z2 = c_color := hs_sub z2 (by simp)
    have h3 : color z3 = c_color := hs_sub z3 (by simp)
    have h4 : color z4 = c_color := hs_sub z4 (by simp)
    simp [h1, h2, h3, h4]
  let I := z1^2 - z2^2 + z3^2 - z4^2
  have h_abs : normSq I = 4 := rectangle_imp_abs_I_eq_two_proved h_par h_perp h_area
  have h_close : ∃ k1 k2 : ℤ, abs (I.re - (k1 : ℝ) * (10 / 3)) < 4 / 3 ∧ abs (I.im - (k2 : ℝ) * (10 / 3)) < 4 / 3 := monochromatic_imp_I_close h_col
  obtain ⟨k1, k2, hk1, hk2⟩ := h_close
  exact no_I_on_circle I k1 k2 h_abs hk1 hk2

/-
If $z_1, z_2, z_3, z_4$ form a rectangle of area 1, then $|z_1^2 - z_2^2 + z_3^2 - z_4^2|^2 = 4$.
-/
open Complex

lemma rectangle_imp_abs_I_eq_two_real {z1 z2 z3 z4 : ℂ}
  (h_par : z2 - z1 = z3 - z4)
  (h_perp : ((z2 - z1) * star (z4 - z1)).re = 0)
  (h_area : normSq (z2 - z1) * normSq (z4 - z1) = 1) :
  normSq (z1^2 - z2^2 + z3^2 - z4^2) = 4 := by
    convert rectangle_imp_abs_I_eq_two h_par h_perp h_area using 1

notation "ℝ²" => EuclideanSpace ℝ (Fin 2)

variable {V P : Type*} {n : ℕ}

variable [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P]

variable [Module.Oriented ℝ V (Fin 2)] [Fact (Module.finrank ℝ V = 2)] {p : Fin n → P}

/-- Oriented angles make sense in 2d.

Note: this can't blindly be added to mathlib as it creates an "instance diamond"
with an instance for modules satisfying `is_empty`. -/
noncomputable instance Module.orientedEuclideanSpaceFinTwo : Module.Oriented ℝ ℝ² (Fin 2) :=
  ⟨Module.Basis.orientation <| Pi.basisFun _ _⟩

/-- Two dimensional euclidean space is two-dimensional. -/
instance fact_finrank_euclideanSpace_fin_two : Fact (Module.finrank ℝ ℝ² = 2) :=
  ⟨finrank_euclideanSpace_fin⟩

/-- The statement that a sequence of points form a counter-clockwise convex polygon. -/
def IsCcwConvexPolygon (p : Fin n → P) : Prop :=
  ∀ ⦃i j k⦄, i < j → j < k → (EuclideanGeometry.oangle (p i) (p j) (p k)).sign = 1

/-- Erdős problem 189 asked whether the below holds for all rectangles. -/
def Erdos189For (P : ℝ² → ℝ² → ℝ² → ℝ² → Prop) (A : ℝ² → ℝ² → ℝ² → ℝ² → ℝ) :=
    ∀ᵉ (n > 0) (colouring : ℝ² → Fin n), ∃ colour, ∀ area > (0 : ℝ), ∃ a b c d,
      {a, b, c, d} ⊆ colouring⁻¹' {colour} ∧
      IsCcwConvexPolygon ![a, b, c, d] ∧
      A a b c d = area ∧
      P a b c d

noncomputable section AristotleLemmas

/-
Map a point in R^2 to a complex number.
-/
open Complex

def toComplex (p : ℝ²) : ℂ := ⟨p 0, p 1⟩

/-
The mapping from R^2 to C is injective.
-/
open Complex

lemma toComplex_inj : Function.Injective toComplex := by
  intro z w h; simp +decide [ Complex.ext_iff ] at h; aesop;
  ext i; fin_cases i <;> aesop

/-
toComplex preserves subtraction.
-/
open Complex EuclideanGeometry

lemma toComplex_sub (x y : ℝ²) : toComplex (x - y) = toComplex x - toComplex y := by
  exact?

/-
The inner product in R^2 corresponds to the real part of the complex product.
-/
open Complex EuclideanGeometry

lemma toComplex_inner (x y : ℝ²) : inner ℝ x y = ((toComplex x) * star (toComplex y)).re := by
  -- Unpack the definitions of `toComplex` and `star`, then calculate the real part of the product.
  simp +decide [toComplex, star, mul_assoc, mul_comm, mul_left_comm];
  simp +decide [ *, Fin.sum_univ_two, Inner.inner ];
  ring

/-
The squared norm in R^2 corresponds to the squared norm of the complex number.
-/
open Complex EuclideanGeometry

lemma toComplex_normSq (x : ℝ²) : ‖x‖^2 = normSq (toComplex x) := by
  norm_num [ EuclideanSpace.norm_eq ];
  rw [ Real.sq_sqrt <| by positivity, Complex.normSq_apply ];
  rw [ ← sq, ← sq, toComplex ]

/-
The directions of the lines ab and bc are perpendicular if and only if the inner product of the vectors b-a and c-b is zero.
-/
open Complex EuclideanGeometry

lemma perp_iff_inner_eq_zero (a b c : ℝ²) :
  line[ℝ, a, b].direction ⟂ line[ℝ, b, c].direction ↔ inner ℝ (b - a) (c - b) = 0 := by
    have h_dir_span : (affineSpan ℝ {a, b}).direction = Submodule.span ℝ {b - a} ∧ (affineSpan ℝ {b, c}).direction = Submodule.span ℝ {c - b} := by
      constructor <;> rw [ direction_affineSpan ];
      · rw [ vectorSpan_pair ];
        rw [ ← Submodule.span_neg ] ; norm_num;
      · simp +decide [ vectorSpan_pair ];
        rw [ ← Submodule.span_neg ] ; norm_num [ neg_sub ] ;
    simp +decide [ h_dir_span, Submodule.isOrtho_span ]

/-
If a, b, c, d form a convex polygon with three right angles, then they form a parallelogram (specifically b - a = c - d).
-/
open Complex EuclideanGeometry

lemma parallelogram_of_rect (a b c d : ℝ²)
  (h_ccw : IsCcwConvexPolygon ![a, b, c, d])
  (h_perp1 : line[ℝ, a, b].direction ⟂ line[ℝ, b, c].direction)
  (h_perp2 : line[ℝ, b, c].direction ⟂ line[ℝ, c, d].direction)
  (h_perp3 : line[ℝ, c, d].direction ⟂ line[ℝ, d, a].direction) :
  b - a = c - d := by
    -- By definition of perpendicularity, we know that the inner product of the vectors is zero.
    have h_inner_zero : inner ℝ (b - a) (c - b) = 0 ∧ inner ℝ (c - b) (d - c) = 0 ∧ inner ℝ (d - c) (a - d) = 0 := by
      exact ⟨ by simpa using ( perp_iff_inner_eq_zero a b c ) |>.1 h_perp1, by simpa using ( perp_iff_inner_eq_zero b c d ) |>.1 h_perp2, by simpa using ( perp_iff_inner_eq_zero c d a ) |>.1 h_perp3 ⟩;
    -- By hypothesis, we know that the vectors (b - a) and (c - d) are perpendicular to (c - b), and (d - c) is perpendicular to (a - d).
    have h_perp : inner ℝ (b - a - (c - d)) (c - b) = 0 ∧ inner ℝ (b - a - (c - d)) (d - c) = 0 := by
      simp_all +decide [ inner_sub_left, inner_sub_right ];
      constructor <;> norm_num [ real_inner_comm ] at * <;> linarith;
    -- Since the vectors (c - b) and (d - c) are linearly independent, the only solution to the system of equations is that (b - a) - (c - d) = 0.
    have h_lin_indep : LinearIndependent ℝ ![c - b, d - c] := by
      have h_lin_indep : c - b ≠ 0 ∧ d - c ≠ 0 := by
        constructor <;> intro h <;> simp_all +decide [ sub_eq_iff_eq_add ];
        · have := h_ccw ( show 0 < 1 from by decide ) ( show 1 < 2 from by decide ) ; simp_all +decide [ IsCcwConvexPolygon ];
        · have := @h_ccw 1 2 3 ( by decide ) ( by decide ) ; simp_all +decide [ EuclideanGeometry.oangle ] ;
      rw [ Fintype.linearIndependent_iff ] ; aesop;
      fin_cases i <;> simp_all +decide [ inner_add_left, inner_add_right, inner_smul_left, inner_smul_right ];
      · replace a_1 := congr_arg ( fun x => inner ℝ x ( c - b ) ) a_1 ; simp_all +decide [ inner_add_left, inner_add_right, inner_smul_left, inner_smul_right ];
        simp_all +decide [ real_inner_comm ];
      · have := congr_arg ( fun x => inner ℝ x ( d - c ) ) a_1 ; norm_num [ left_3, right_1, right_2, left_2, inner_add_left, inner_add_right, inner_smul_left, inner_smul_right ] at this ; aesop;
    have h_lin_comb : ∀ (v : EuclideanSpace ℝ (Fin 2)), (∀ i : Fin 2, inner ℝ v (![c - b, d - c] i) = 0) → v = 0 := by
      intro v hv
      have h_ortho : v ∈ (Submodule.span ℝ (Set.range ![c - b, d - c]))ᗮ := by
        intro w hw;
        rw [ Submodule.mem_span_range_iff_exists_fun ] at hw;
        aesop;
        simp_all +decide [ inner_add_left, inner_smul_left ];
        simp_all +decide [ real_inner_comm ];
      have h_ortho : v ∈ (Submodule.span ℝ (Set.range ![c - b, d - c]))ᗮ → v = 0 := by
        intro hv
        have h_subspace : Submodule.span ℝ (Set.range ![c - b, d - c]) = ⊤ := by
          refine' Submodule.eq_top_of_finrank_eq _;
          rw [ finrank_span_eq_card ] <;> aesop
        aesop;
      exact h_ortho ‹_›;
    exact sub_eq_zero.mp ( h_lin_comb _ fun i => by fin_cases i <;> tauto )

/-
If a, b, c, d form a rectangle in R^2 with area 1 (satisfying the Erdos189 conditions), then their complex representations form a rectangle of area 1 in C.
Proof idea:
1. Use `parallelogram_of_rect` to show `b - a = c - d`.
2. Use `toComplex_sub` to translate this to `toComplex b - toComplex a = toComplex c - toComplex d`.
3. Use `perp_iff_inner_eq_zero` and `toComplex_inner` to show the perpendicularity condition.
   Note that `line[ℝ, c, d] ⟂ line[ℝ, d, a]` implies `inner (d - c) (a - d) = 0`.
   Since `c - d = -(d - c)` and `b - a = c - d`, we have `d - c = -(b - a)`.
   So `inner (b - a) (d - a) = 0`.
4. Use `toComplex_normSq` and `dist_eq_norm` to show the area condition.
   `dist a b * dist b c = 1` implies `‖b - a‖ * ‖c - b‖ = 1`.
   Since it's a parallelogram, `‖c - b‖ = ‖d - a‖`.
   So `‖b - a‖ * ‖d - a‖ = 1`.
   Squaring gives `‖b - a‖^2 * ‖d - a‖^2 = 1`.
   Translate to complex norms.
5. Distinctness follows from `IsCcwConvexPolygon`.
-/
open Complex EuclideanGeometry

lemma is_rectangle_of_erdos (a b c d : ℝ²)
  (h_ccw : IsCcwConvexPolygon ![a, b, c, d])
  (h_perp1 : line[ℝ, a, b].direction ⟂ line[ℝ, b, c].direction)
  (h_perp2 : line[ℝ, b, c].direction ⟂ line[ℝ, c, d].direction)
  (h_perp3 : line[ℝ, c, d].direction ⟂ line[ℝ, d, a].direction)
  (h_area : dist a b * dist b c = 1) :
  IsRectangleArea1 {toComplex a, toComplex b, toComplex c, toComplex d} := by
    refine' ⟨ toComplex a, toComplex b, toComplex c, toComplex d, _, _, _, _, _, _ ⟩ <;> simp_all +decide [ IsCcwConvexPolygon, dist_eq_norm, EuclideanSpace.norm_eq ];
    · intro h; simp_all +decide [ toComplex ];
    · intro heq; simp_all +decide [ Fin.forall_fin_succ, Complex.ext_iff ] ;
      norm_num [ show a = c from by ext i; fin_cases i <;> aesop ] at *;
    · intro h; simp_all +decide [ Fin.forall_fin_succ, Complex.ext_iff ] ;
      unfold toComplex at h; aesop;
      norm_num [ show a = d from by ext i; fin_cases i <;> assumption ] at *;
    · intro h; have := congr_arg Complex.re h; have := congr_arg Complex.im h; simp_all +decide [ toComplex ];
    · refine' ⟨ _, _, _, _, _ ⟩;
      · intro h; simp_all +decide [ toComplex ] ;
        norm_num [ show b = d from by ext i; fin_cases i <;> tauto ] at *;
        simp_all +decide [ Fin.forall_fin_succ ];
      · norm_num [ Complex.ext_iff, toComplex ];
        intro h₀ h₁; simp_all +decide [ Fin.forall_fin_succ ] ;
        simp_all +decide [ show c = d from by ext i; fin_cases i <;> assumption ];
      · have h_par : b - a = c - d := by
          apply parallelogram_of_rect a b c d h_ccw h_perp1 h_perp2 h_perp3;
        exact toComplex_sub b a ▸ toComplex_sub c d ▸ congr_arg toComplex h_par;
      · have h_inner : inner ℝ (d - a) (b - a) = 0 := by
          have h_inner : inner ℝ (c - d) (d - a) = 0 := by
            simp_all +decide [ Submodule.mem_orthogonal, direction_affineSpan ];
            simp_all +decide [ vectorSpan_pair, Submodule.mem_orthogonal ];
          have h_inner : b - a = c - d := by
            apply parallelogram_of_rect;
            · exact h_ccw;
            · assumption;
            · assumption;
            · assumption;
          rw [ h_inner, real_inner_comm ] ; aesop;
        simp_all +decide [ toComplex, inner ];
        linarith;
      · unfold toComplex; simp_all +decide [ Complex.normSq, sq ] ;
        -- By definition of $d$, we know that $d = a + (c - b)$.
        have hd : d = a + (c - b) := by
          have := parallelogram_of_rect a b c d h_ccw h_perp1 h_perp2 h_perp3;
          exact eq_add_of_sub_eq' ( by ext i; have := congr_fun this i; norm_num at *; linarith );
        rw [ ← Real.sqrt_mul <| by nlinarith ] at h_area;
        rw [ Real.sqrt_eq_one ] at h_area ; aesop ; nlinarith

end AristotleLemmas

theorem erdos_189 :
    Erdos189For
      (fun a b c d ↦
        line[ℝ, a, b].direction ⟂ line[ℝ, b, c].direction ∧
        line[ℝ, b, c].direction ⟂ line[ℝ, c, d].direction ∧
        line[ℝ, c, d].direction ⟂ line[ℝ, d, a].direction)
      (fun a b c d ↦ dist a b * dist b c) ↔ False := by
  refine' iff_false_intro _;
  -- By definition of Erdos189For, we need to show that there exists a coloring with 25 colors such that no monochromatic rectangle of area 1 exists.
  intro h
  obtain ⟨f, hf⟩ := partition_rectangles_final_v4;
  obtain ⟨ n, hn ⟩ := h 25 ( by norm_num ) ( fun x => f ( toComplex x ) );
  obtain ⟨ a, b, c, d, h₁, h₂, h₃, h₄ ⟩ := hn 1 zero_lt_one;
  -- Apply `is_rectangle_of_erdos` to obtain that `{toComplex a, toComplex b, toComplex c, toComplex d}` forms a rectangle of area 1 in `ℂ`.
  have h_rect : IsRectangleArea1 {toComplex a, toComplex b, toComplex c, toComplex d} := by
    apply is_rectangle_of_erdos a b c d h₂ h₄.left h₄.right.left h₄.right.right h₃;
  exact hf n ⟨ _, by simpa [ Set.subset_def ] using h₁, h_rect ⟩
