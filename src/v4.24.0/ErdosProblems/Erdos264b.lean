/-
This is a Lean formalization of a negative answer to the first half of Erdos Problem 264.
https://www.erdosproblems.com/264

The final statement was available from the Formal Conjectures project.

Statement from Erdos Problems:
Let $a_n$ be a sequence of integers such that for every bounded sequence of integers $b_n$ (with $a_n+b_n\neq 0$ and $b_n\neq 0$ for all $n$) the sum\[\sum \frac{1}{a_n+b_n}\]is irrational. Is $a_n=2^n$ an example of such a sequence?

Clean statement:
There exists a sequence $(b_k)_{k=1}^{\infty}$ with values in the set $\{1,2,3,4,5\}$ such that the infinite sum $\sum_{k=1}^{\infty} \frac{1}{2^k+b_k}$ is a rational number.

The original human proof was published in the paper
V. Kovac, T. Tao, On several irrationality problems for Ahmes series, Acta Math. Hungar. 175 (2025), 572-608, arXiv:2406.17593.

LaTeX blueprint of the proof prepared by V. Kovac
https://web.math.pmf.unizg.hr/~vjekovac/EP/EP264/Erdos264_blueprint.tex
was auto-formalized into Lean by Aristotle (Harmonic).

The rest of the file was generated by Aristotle on 2025-12-17.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a67c0f75-a2fd-41c4-9c0e-f8f8b9bc40ab
-/

/-
We prove that there exists a sequence $(b_k)_{k=1}^{\infty}$ with values in $\{1,2,3,4,5\}$ such that the infinite sum $\sum_{k=1}^{\infty} \frac{1}{2^k+b_k}$ is a rational number. This is achieved by constructing the sequence recursively to ensure the partial sums converge to a specific rational number $x$ chosen between $\alpha_0$ and $\beta_0$. The proof involves two lemmas establishing bounds on the tails of the series and a recursive step lemma that guarantees the existence of the next term in the sequence.
-/

import Mathlib

namespace Erdos264b

set_option linter.mathlibStandardSet false

open scoped BigOperators

open scoped Real

open scoped Nat

open scoped Classical

open scoped Pointwise

set_option maxHeartbeats 0

set_option maxRecDepth 4000

set_option synthInstance.maxHeartbeats 20000

set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false

set_option autoImplicit false

noncomputable section

/-
Definition of alpha_n as the sum from k=n+1 to infinity of 1/(2^k + 5).
-/
noncomputable def alpha (n : ℕ) : ℝ := ∑' k, 1 / ((2 : ℝ)^(n + 1 + k) + 5)

/-
Definition of beta_n as the sum from k=n+1 to infinity of 1/(2^k + 1).
-/
noncomputable def beta (n : ℕ) : ℝ := ∑' k, 1 / ((2 : ℝ)^(n + 1 + k) + 1)

/-
For every integer n>=0 we have alpha_n < beta_n.
-/
theorem lemma1 (n : ℕ) : alpha n < beta n := by
  -- Rewrite $\alpha_n$ and $\beta_n$ using their definitions.
  have h_def : alpha n = ∑' k, (1 / (((2 : ℝ)^(n + 1 + k) + 5))) ∧ beta n = ∑' k, (1 / (((2 : ℝ)^(n + 1 + k) + 1))) := by
    exact ⟨ rfl, rfl ⟩;
  aesop;
  fapply Summable.tsum_lt_tsum;
  use 0;
  · exact fun k => inv_anti₀ ( by positivity ) ( by linarith );
  · gcongr ; norm_num;
  · exact Summable.of_nonneg_of_le ( fun _ => by positivity ) ( fun m => by simpa using inv_anti₀ ( by positivity ) ( show ( 2 ^ ( n + 1 + m ) + 5 : ℝ ) ≥ 2 ^ ( n + 1 + m ) by linarith ) ) ( by simpa using summable_geometric_two.comp_injective ( by aesop_cat ) );
  · exact Summable.of_nonneg_of_le ( fun _ ↦ by positivity ) ( fun _ ↦ by simpa using inv_anti₀ ( by positivity ) ( show ( 2 ^ ( n + 1 + ‹_› ) + 1 : ℝ ) ≥ 2 ^ ( n + 1 + ‹_› ) by norm_num ) ) ( by simpa using summable_geometric_two.comp_injective ( by aesop_cat ) )

/-
For every integer n>=0 we have beta_{n+1} >= alpha_{n+1} + 1/((2^{n+1}+1)(2^{n+1}+2)).
-/
theorem lemma2 (n : ℕ) : beta (n + 1) ≥ alpha (n + 1) + 1 / ((2^(n + 1) + 1) * (2^(n + 1) + 2)) := by
  -- By Lemma 1, we have $\beta_{n+1} - \alpha_{n+1} \geq \frac{1}{2^{n+2}+1} - \frac{1}{2^{n+2}+5}$.
  have h_diff_lower_bound : (beta (n + 1)) - (alpha (n + 1)) ≥ (1 / ((2 ^ (n + 2) + 1) * (2 ^ (n + 2) + 5) : ℝ)) * 4 := by
    -- By Lemma 1, we can write $\beta_{n+1} - \alpha_{n+1}$ as a sum of differences.
    have h_beta_alpha_sum : (beta (n + 1)) - (alpha (n + 1)) = (∑' (k : ℕ), (1 / (((2 : ℝ)^(n + 1 + 1 + k)) + 1) - 1 / (((2 : ℝ)^(n + 1 + 1 + k)) + 5))) := by
      unfold beta alpha; aesop;
      rw [ Summable.tsum_sub ];
      · exact Summable.of_nonneg_of_le ( fun _ ↦ by positivity ) ( fun k ↦ by simpa using inv_anti₀ ( by positivity ) ( show ( 2 ^ ( n + 1 + 1 + k ) + 1 : ℝ ) ≥ 2 ^ ( n + 1 + 1 + k ) by norm_num ) ) ( by simpa using summable_geometric_two.comp_injective ( by aesop_cat ) );
      · exact Summable.of_nonneg_of_le ( fun _ ↦ by positivity ) ( fun k ↦ by simpa using inv_anti₀ ( by positivity ) ( show ( 2:ℝ ) ^ ( n + 1 + 1 + k ) + 5 ≥ ( 2:ℝ ) ^ ( n + 1 + 1 + k ) by norm_num ) ) ( by simpa using summable_geometric_two.comp_injective <| by aesop_cat );
    rw [ h_beta_alpha_sum, Summable.tsum_eq_zero_add ] <;> norm_num;
    · exact le_add_of_le_of_nonneg ( by nlinarith only [ inv_pos.mpr ( by positivity : 0 < ( 2:ℝ ) ^ ( n+2 ) +5 ), inv_pos.mpr ( by positivity : 0 < ( 2:ℝ ) ^ ( n+2 ) +1 ), mul_inv_cancel₀ ( by positivity : ( 2:ℝ ) ^ ( n+2 ) +5 ≠ 0 ), mul_inv_cancel₀ ( by positivity : ( 2:ℝ ) ^ ( n+2 ) +1 ≠ 0 ) ] ) ( tsum_nonneg fun _ => sub_nonneg.mpr <| inv_anti₀ ( by positivity ) <| by gcongr ; norm_num );
    · refine' Summable.of_nonneg_of_le _ _ _;
      use fun k => 1 / ( 2 ^ ( n + 1 + 1 + k ) );
      · exact fun k => sub_nonneg_of_le <| inv_anti₀ ( by positivity ) <| by linarith [ pow_pos ( by norm_num : ( 0 : ℝ ) < 2 ) ( n + 1 + 1 + k ) ] ;
      · field_simp;
        exact fun k => by nlinarith [ pow_pos ( zero_lt_two' ℝ ) ( n + 1 + 1 + k ) ] ;
      · simpa using summable_geometric_two.comp_injective ( add_right_injective _ );
  norm_num [ pow_succ' ] at *;
  -- Let's simplify the inequality.
  field_simp at *;
  nlinarith [ pow_pos ( zero_lt_two' ℝ ) n, pow_mul ( 2 : ℝ ) n 2 ]

/-
Given bounds at step n, there exists a next term b_{n+1} in {1,..,5} such that the bounds hold at step n+1.
-/
theorem recursive_step (n : ℕ) (current_sum : ℝ) (x : ℝ)
  (h_bounds : current_sum + alpha n ≤ x ∧ x ≤ current_sum + beta n) :
  ∃ b_next ∈ ({1, 2, 3, 4, 5} : Set ℕ),
    current_sum + 1 / ((2 : ℝ)^(n + 1) + (b_next : ℝ)) + alpha (n + 1) ≤ x ∧
    x ≤ current_sum + 1 / ((2 : ℝ)^(n + 1) + (b_next : ℝ)) + beta (n + 1) := by
      -- Let's choose $b_{n+1}$ to be the largest integer in $\{1, 2, 3, 4, 5\}$ such that $x \leq \sum_{k=1}^{n} \frac{1}{2^k+b_k} + \frac{1}{2^{n+1}+b_{n+1}} + \beta_{n+1}$.
      obtain ⟨b_next, hb_next_def⟩ : ∃ b_next ∈ Finset.Icc (1 : ℕ) 5, x ≤ current_sum + 1 / ((2 : ℝ)^(n + 1) + b_next) + beta (n + 1) ∧ ∀ c ∈ Finset.Icc (1 : ℕ) 5, c > b_next → ¬(x ≤ current_sum + 1 / ((2 : ℝ)^(n + 1) + c) + beta (n + 1)) := by
        -- By definition of $beta$, we know that $x \leq current\_sum + \frac{1}{2^{n+1} + 1} + \beta (n + 1)$.
        have h_beta : x ≤ current_sum + 1 / ((2 : ℝ)^(n + 1) + 1) + beta (n + 1) := by
          -- By definition of $beta$, we can split the sum into the first term and the rest.
          have h_beta_split : beta n = 1 / ((2 : ℝ)^(n + 1) + 1) + beta (n + 1) := by
            unfold beta; aesop;
            rw [ Summable.tsum_eq_zero_add ] ; norm_num [ pow_add ] ; ring; (
            exact Summable.of_nonneg_of_le ( fun _ => by positivity ) ( fun k => by simpa using inv_anti₀ ( by positivity ) ( show ( 2 ^ ( n + 1 + k ) + 1 : ℝ ) ≥ 2 ^ ( n + 1 + k ) by linarith ) ) ( by simpa using summable_geometric_two.comp_injective ( by aesop_cat ) ));
          linarith;
        exact ⟨ Finset.max' ( Finset.filter ( fun c : ℕ => x ≤ current_sum + 1 / ( 2 ^ ( n + 1 ) + c : ℝ ) + beta ( n + 1 ) ) ( Finset.Icc 1 5 ) ) ⟨ 1, by norm_num; aesop ⟩, Finset.mem_filter.mp ( Finset.max'_mem ( Finset.filter ( fun c : ℕ => x ≤ current_sum + 1 / ( 2 ^ ( n + 1 ) + c : ℝ ) + beta ( n + 1 ) ) ( Finset.Icc 1 5 ) ) ⟨ 1, by norm_num; aesop ⟩ ) |>.1, Finset.mem_filter.mp ( Finset.max'_mem ( Finset.filter ( fun c : ℕ => x ≤ current_sum + 1 / ( 2 ^ ( n + 1 ) + c : ℝ ) + beta ( n + 1 ) ) ( Finset.Icc 1 5 ) ) ⟨ 1, by norm_num; aesop ⟩ ) |>.2, fun c hc hbc hxc => not_lt_of_ge ( Finset.le_max' _ _ <| by aesop ) hbc ⟩;
      -- If $b_{n+1}=5$, then \eqref{property2} and \eqref{ineq1} together give
      by_cases hb_next_eq_5 : b_next = 5;
      · use 5; aesop;
        -- By definition of $alpha$, we know that
        have h_alpha : alpha n = 1 / ((2 : ℝ)^(n + 1) + 5) + alpha (n + 1) := by
          unfold alpha; rw [ Summable.tsum_eq_zero_add ] ; norm_num; ring;
          norm_num [ pow_add ];
          exact Summable.of_nonneg_of_le ( fun _ => by positivity ) ( fun k => by rw [ inv_le_comm₀ ] <;> norm_num <;> ring <;> nlinarith [ pow_le_pow_right₀ ( by norm_num : ( 1 : ℝ ) ≤ 2 ) n.zero_le, pow_le_pow_right₀ ( by norm_num : ( 1 : ℝ ) ≤ 2 ) k.zero_le ] ) ( summable_geometric_two );
        norm_num at * ; linarith;
      · -- Otherwise, if $b_{n+1}\in\{1,2,3,4\}$, then the maximality from its definition gives
        -- \[ x > \sum_{k=1}^{n} \frac{1}{2^k+b_k} + \frac{1}{2^{n+1}+b_{n+1}+1} + \beta_{n+1}, \]
        have hx_gt : x > current_sum + 1 / ((2 : ℝ)^(n + 1) + (b_next + 1 : ℕ)) + beta (n + 1) := by
          exact lt_of_not_ge ( hb_next_def.2.2 ( b_next + 1 ) ( Finset.mem_Icc.mpr ⟨ by linarith [ Finset.mem_Icc.mp hb_next_def.1 ], by linarith [ Finset.mem_Icc.mp hb_next_def.1, Nat.lt_of_le_of_ne ( Finset.mem_Icc.mp hb_next_def.1 |>.2 ) hb_next_eq_5 ] ⟩ ) ( by linarith [ Finset.mem_Icc.mp hb_next_def.1 ] ) );
        -- Using Lemma 2, we have $\beta_{n+1} \geq \alpha_{n+1} + \frac{1}{(2^{n+1}+1)(2^{n+1}+2)}$.
        have h_beta_alpha : beta (n + 1) ≥ alpha (n + 1) + 1 / ((2^(n + 1) + 1) * (2^(n + 1) + 2) : ℝ) := by
          exact?;
        -- Using the inequality $\frac{1}{(2^{n+1}+b_{n+1})(2^{n+1}+b_{n+1}+1)} \leq \frac{1}{(2^{n+1}+1)(2^{n+1}+2)}$, we get
        have h_ineq : 1 / ((2^(n + 1) + (b_next : ℕ)) * (2^(n + 1) + (b_next + 1) : ℕ) : ℝ) ≤ 1 / ((2^(n + 1) + 1) * (2^(n + 1) + 2) : ℝ) := by
          gcongr <;> norm_cast <;> aesop;
        use b_next; aesop;
        · interval_cases b_next <;> trivial;
        · nlinarith [ inv_pos.mpr ( by positivity : 0 < ( 2 : ℝ ) ^ ( n + 1 ) + ( b_next : ℝ ) ), inv_pos.mpr ( by positivity : 0 < ( 2 : ℝ ) ^ ( n + 1 ) + ( b_next + 1 : ℝ ) ), mul_inv_cancel₀ ( by positivity : ( 2 : ℝ ) ^ ( n + 1 ) + ( b_next : ℝ ) ≠ 0 ), mul_inv_cancel₀ ( by positivity : ( 2 : ℝ ) ^ ( n + 1 ) + ( b_next + 1 : ℝ ) ≠ 0 ) ]

/-
There exists a sequence b_k with values in {1,2,3,4,5} such that the sum of 1/(2^k + b_k) is a rational number.
-/
theorem main_theorem : ∃ b : ℕ → ℕ, (∀ k, b k ∈ ({1, 2, 3, 4, 5} : Set ℕ)) ∧ ∃ q : ℚ, (∑' k, 1 / ((2 : ℝ)^(k + 1) + (b (k + 1) : ℝ))) = (q : ℝ) := by
  -- By Lemma 1, we have $\alpha_0 < \beta_0$, so there exists a rational number $x$ such that $\alpha_0 \le x \le \beta_0$.
  obtain ⟨x, hx_bounds⟩ : ∃ x : ℚ, (alpha 0 : ℝ) ≤ x ∧ x ≤ (beta 0 : ℝ) := by
    -- By Lemma 1, we know that $\alpha_0 < \beta_0$.
    have h_alpha_beta : alpha 0 < beta 0 := by
      exact?;
    exact mod_cast exists_rat_btwn h_alpha_beta |> fun ⟨ x, hx₁, hx₂ ⟩ => ⟨ x, hx₁.le, hx₂.le ⟩;
  -- By the recursive step, we can construct the sequence $b_k$ such that the partial sums converge to $x$.
  obtain ⟨b, hb⟩ : ∃ b : ℕ → ℕ, (∀ k, (b k ∈ ({1, 2, 3, 4, 5} : Set ℕ))) ∧ ∀ n, (∑ k ∈ Finset.range n, (1 / ((2 : ℝ)^(k + 1) + (b (k + 1))))) + (alpha n : ℝ) ≤ x ∧ x ≤ (∑ k ∈ Finset.range n, (1 / ((2 : ℝ)^(k + 1) + (b (k + 1))))) + (beta n : ℝ) := by
    have h_seq : ∀ n, ∃ b : ℕ → ℕ, (∀ k, (b k ∈ ({1, 2, 3, 4, 5} : Set ℕ))) ∧ ∀ m ≤ n, (∑ k ∈ Finset.range m, (1 / ((2 : ℝ)^(k + 1) + (b (k + 1))))) + (alpha m : ℝ) ≤ x ∧ x ≤ (∑ k ∈ Finset.range m, (1 / ((2 : ℝ)^(k + 1) + (b (k + 1))))) + (beta m : ℝ) := by
      intro n
      induction' n with n ih;
      · aesop;
      · obtain ⟨ b, hb₁, hb₂ ⟩ := ih;
        -- By the recursive step, there exists a $b_{n+1} \in \{1, 2, 3, 4, 5\}$ such that the bounds hold for $n+1$.
        obtain ⟨ b_next, hb_next ⟩ : ∃ b_next ∈ ({1, 2, 3, 4, 5} : Set ℕ), (∑ k ∈ Finset.range n, (1 / ((2 : ℝ)^(k + 1) + (b (k + 1))))) + (1 / ((2 : ℝ)^(n + 1) + (b_next : ℝ))) + (alpha (n + 1) : ℝ) ≤ x ∧ x ≤ (∑ k ∈ Finset.range n, (1 / ((2 : ℝ)^(k + 1) + (b (k + 1))))) + (1 / ((2 : ℝ)^(n + 1) + (b_next : ℝ))) + (beta (n + 1) : ℝ) := by
          convert recursive_step n _ _ _ using 1;
          exact hb₂ n le_rfl;
        refine' ⟨ fun k => if k = n + 1 then b_next else b k, _, _ ⟩ <;> simp_all +decide;
        · grind +ring;
        · intro m hm; cases hm <;> simp_all +decide [ Finset.sum_range_succ ] ;
          · convert hb_next.2 using 2 <;> rw [ Finset.sum_congr rfl ] <;> aesop;
          · convert hb₂ m ‹_› using 2 <;> congr! 1;
            · exact Finset.sum_congr rfl fun x hx => by rw [ if_neg ( by linarith [ Finset.mem_range.mp hx ] ) ] ;
            · exact Finset.sum_congr rfl fun x hx => by rw [ if_neg ( by linarith [ Finset.mem_range.mp hx ] ) ] ;
    choose f hf1 hf2 using h_seq;
    -- By the properties of the sequence $(f_n)$, we can extract a subsequence $(f_{n_k})$ that converges pointwise to some function $b$.
    obtain ⟨b, hb⟩ : ∃ b : ℕ → ℕ, (∀ k, b k ∈ ({1, 2, 3, 4, 5} : Set ℕ)) ∧ ∃ (subseq : ℕ → ℕ), StrictMono subseq ∧ ∀ k, Filter.Tendsto (fun n => f (subseq n) k) Filter.atTop (nhds (b k)) := by
      have h_compact : IsCompact (Set.pi Set.univ fun k : ℕ => ({1, 2, 3, 4, 5} : Set ℕ)) := by
        exact isCompact_univ_pi fun _ => isCompact_singleton.union ( isCompact_singleton.union ( isCompact_singleton.union ( isCompact_singleton.union ( isCompact_singleton ) ) ) );
      have := h_compact.isSeqCompact fun n => show f n ∈ Set.pi Set.univ fun k => { 1, 2, 3, 4, 5 } from fun k _ => hf1 n k;
      exact ⟨ this.choose, fun k => this.choose_spec.1 k trivial, this.choose_spec.2.choose, this.choose_spec.2.choose_spec.1, fun k => tendsto_pi_nhds.mp this.choose_spec.2.choose_spec.2 k ⟩;
    use b; aesop;
    · -- By the properties of the subsequence, we have that for all $m \leq n$, $\sum_{k=0}^{m-1} \frac{1}{2^{k+1} + f_{w(n)}(k+1)} + \alpha_m \leq x$.
      have h_subseq : ∀ m ≤ n, ∑ k ∈ Finset.range m, (2 ^ (k + 1) + (b (k + 1) : ℝ))⁻¹ + alpha m ≤ x := by
        intros m hm
        have h_subseq : ∀ᶠ n in Filter.atTop, ∑ k ∈ Finset.range m, (2 ^ (k + 1) + (f (w n) (k + 1) : ℝ))⁻¹ + alpha m ≤ x := by
          exact Filter.eventually_atTop.mpr ⟨ n, fun k hk => hf2 _ _ ( le_trans hm ( left_2.id_le _ |> le_trans hk ) ) |>.1 ⟩;
        have h_subseq : Filter.Tendsto (fun n => ∑ k ∈ Finset.range m, (2 ^ (k + 1) + (f (w n) (k + 1) : ℝ))⁻¹ + alpha m) Filter.atTop (nhds (∑ k ∈ Finset.range m, (2 ^ (k + 1) + (b (k + 1) : ℝ))⁻¹ + alpha m)) := by
          refine' Filter.Tendsto.add _ tendsto_const_nhds;
          exact tendsto_finset_sum _ fun i hi => Filter.Tendsto.inv₀ ( tendsto_const_nhds.add <| tendsto_const_nhds.congr' <| by filter_upwards [ Filter.eventually_ge_atTop ( right_1 ( i + 1 ) |> Classical.choose ) ] with n hn; rw [ right_1 ( i + 1 ) |> Classical.choose_spec |> fun h => h n hn ] ) <| by positivity;
        exact le_of_tendsto h_subseq ( by aesop );
      exact h_subseq n le_rfl;
    · -- By the properties of the sequence $(f_n)$, we can extract a subsequence $(f_{n_k})$ that converges pointwise to some function $b$. Hence, for any $n$, we have:
      have h_subseq : Filter.Tendsto (fun m => ∑ k ∈ Finset.range n, (2 ^ (k + 1) + (f (w m) (k + 1)) : ℝ)⁻¹) Filter.atTop (nhds (∑ k ∈ Finset.range n, (2 ^ (k + 1) + (b (k + 1)) : ℝ)⁻¹)) := by
        exact tendsto_finset_sum _ fun i hi => Filter.Tendsto.inv₀ ( tendsto_const_nhds.add <| tendsto_const_nhds.congr' <| by filter_upwards [ Filter.eventually_ge_atTop ( Classical.choose ( right_1 ( i + 1 ) ) ) ] with m hm; rw [ Classical.choose_spec ( right_1 ( i + 1 ) ) m hm ] ) <| by positivity;
      have h_subseq : ∀ᶠ m in Filter.atTop, ∑ k ∈ Finset.range n, (2 ^ (k + 1) + (f (w m) (k + 1)) : ℝ)⁻¹ + alpha n ≤ x ∧ x ≤ ∑ k ∈ Finset.range n, (2 ^ (k + 1) + (f (w m) (k + 1)) : ℝ)⁻¹ + beta n := by
        exact Filter.eventually_atTop.mpr ⟨ n, fun m hm => hf2 _ _ <| hm.trans <| left_2.id_le _ ⟩;
      aesop;
      exact le_of_tendsto_of_tendsto tendsto_const_nhds ( h_subseq_1.add_const _ ) ( Filter.eventually_atTop.mpr ⟨ w_1, fun m hm => h m hm |>.2 ⟩ );
  -- By the properties of the series, we know that the partial sums converge to $x$.
  have h_sum_converges : Filter.Tendsto (fun n => (∑ k ∈ Finset.range n, (1 / ((2 : ℝ)^(k + 1) + (b (k + 1)) : ℝ)))) Filter.atTop (nhds x) := by
    -- Since $\alpha_n$ and $\beta_n$ tend to $0$ as $n$ tends to infinity, we can apply the squeeze theorem.
    have h_alpha_beta_zero : Filter.Tendsto (fun n => alpha n) Filter.atTop (nhds 0) ∧ Filter.Tendsto (fun n => beta n) Filter.atTop (nhds 0) := by
      constructor;
      · -- We'll use the fact that if the series $\sum_{k=n+1}^{\infty} \frac{1}{2^k + 5}$ converges, then its limit is $0$.
        have h_sum_zero : Filter.Tendsto (fun n => ∑' k, (1 / ((2 : ℝ)^(n + 1 + k) + 5))) Filter.atTop (nhds 0) := by
          convert tendsto_sum_nat_add fun k => ( 1 : ℝ ) / ( 2 ^ ( k + 1 ) + 5 ) using 2 ; norm_num [ add_comm, add_left_comm, add_assoc ];
        convert h_sum_zero using 1;
      · -- By definition of $\beta_n$, we have $\beta_n \leq \sum_{k=n+1}^{\infty} \frac{1}{2^k}$.
        have h_beta_le : ∀ n, (beta n : ℝ) ≤ ∑' k : ℕ, (1 / ((2 : ℝ)^(n + 1 + k))) := by
          intro n; exact Summable.tsum_le_tsum ( fun k => by gcongr ; norm_num ) ( by exact Summable.of_nonneg_of_le ( fun _ => by positivity ) ( fun k => by simpa using inv_anti₀ ( by positivity ) ( show ( 2 : ℝ ) ^ ( n + 1 + k ) + 1 ≥ 2 ^ ( n + 1 + k ) by norm_num ) ) ( by simpa using summable_geometric_two.comp_injective ( by aesop_cat ) ) ) ( by simpa using summable_geometric_two.comp_injective ( by aesop_cat ) ) ;
        -- The series $\sum_{k=n+1}^{\infty} \frac{1}{2^k}$ is a geometric series with sum $\frac{1}{2^n}$.
        have h_geo_series : ∀ n, ∑' k : ℕ, (1 / ((2 : ℝ)^(n + 1 + k))) = (1 / ((2 : ℝ)^(n + 1))) / (1 - 1 / 2) := by
          intro n; ring;
          rw [ tsum_mul_right, tsum_mul_left, tsum_geometric_of_lt_one ] <;> ring <;> norm_num;
        aesop;
        exact squeeze_zero ( fun n => tsum_nonneg fun _ => by positivity ) h_beta_le ( by exact le_trans ( Filter.Tendsto.div_const ( tendsto_inv_atTop_zero.comp ( tendsto_pow_atTop_atTop_of_one_lt one_lt_two |> Filter.Tendsto.comp <| Filter.tendsto_add_atTop_nat _ ) ) _ ) <| by norm_num );
    rw [ Metric.tendsto_nhds ] at *;
    intro ε hε; filter_upwards [ h_alpha_beta_zero.1 ε hε, h_alpha_beta_zero.2.eventually <| Metric.ball_mem_nhds _ hε ] with n hn hn'; exact abs_lt.mpr ⟨ by linarith [ abs_lt.mp hn, abs_lt.mp hn', hb.2 n ], by linarith [ abs_lt.mp hn, abs_lt.mp hn', hb.2 n ] ⟩ ;
  exact ⟨ b, by simpa using hb.1, x, tendsto_nhds_unique ( by exact ( Summable.hasSum <| by exact ( by by_contra h; exact not_tendsto_atTop_of_tendsto_nhds ( h_sum_converges ) <| by exact not_summable_iff_tendsto_nat_atTop_of_nonneg ( fun _ => by positivity ) |>.1 h ) ) |> HasSum.tendsto_sum_nat ) h_sum_converges |> fun h => h.symm ▸ by norm_num ⟩

def IsIrrationalitySequence (a : ℕ → ℕ) : Prop := ∀ b : ℕ → ℕ, BddAbove (Set.range b) →
  0 ∉ Set.range (a + b) → 0 ∉ Set.range b → Irrational (∑' n, (1 : ℝ) / (a n + b n))

theorem erdos_264.parts.i : ¬IsIrrationalitySequence (2 ^ ·) := by
  bound;
  -- Apply the main theorem to obtain a contradiction.
  obtain ⟨b, hb⟩ := main_theorem;
  specialize a b;
  aesop; -- This should lead to a contradiction because we have a rational sum, contradicting the assumption that the sum is irrational.;
  -- Apply the assumption `a` to the range of `b`, which is bounded above by 5.
  have h_bdd : BddAbove (Set.range b) := by
    exact ⟨ 5, Set.forall_mem_range.mpr fun k => by rcases left k with ( h | h | h | h | h ) <;> norm_num [ h ] ⟩;
  specialize a h_bdd ( fun x => by cases left x <;> aesop ) ; erw [ Summable.tsum_eq_zero_add ] at a <;> norm_num at * ; aesop;
  exact Summable.of_nonneg_of_le ( fun n => inv_nonneg.2 ( by positivity ) ) ( fun n => inv_anti₀ ( by positivity ) ( show ( 2 ^ n + ( b n : ℝ ) ) ≥ 2 ^ n by exact le_add_of_nonneg_right ( Nat.cast_nonneg _ ) ) ) ( by simpa using summable_geometric_two )
