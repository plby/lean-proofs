/-

This is a Lean formalization of a solution to Erdős Problem 435.
https://www.erdosproblems.com/forum/thread/435

The original proof was found by: Hwang & Song and Peake & Cambie

[HwSo24] W. Hwang and K. Song, The Frobenius problem for Numerical
Semigroups generated by binomial coefficients. arXiv:2412.17882
(2024).


Cambie's proof from the forum link above was auto-formalized by
Aristotle (from Harmonic).


The proof is verified by Lean.  The following version numbers were
used:

Lean Toolchain version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7 (v4.24.0)

-/


/-
We prove that for a natural number $n$ which is not a prime power, the largest integer not representable as a non-negative integer linear combination of binomial coefficients $\binom{n}{i}$ ($1 \le i < n$) is $target(n) = \sum_{p|n} \sum_{j=1}^{v_p(n)} (p-1)\binom{n}{p^j} - n$.
-/

import Mathlib


/-
The set of generators consists of binomial coefficients $\binom{n}{i}$ for $1 \le i < n$.
-/
def generators (n : ℕ) : Set ℕ :=
  { m | ∃ i, 1 ≤ i ∧ i < n ∧ m = Nat.choose n i }

/-
The target integer is defined as $\sum_k \left( \sum_{1\leq d\leq a_k}\binom{n}{p_k^d}\right)(p_k-1)-n$ where $n=\prod p_k^{a_k}$.
-/
noncomputable def target (n : ℕ) : ℤ :=
  (Finset.sum n.factorization.support fun p =>
    (Finset.sum (Finset.Icc 1 (n.factorization p)) fun d => (Nat.choose n (p ^ d) : ℤ)) * (p - 1)) - n

set_option maxHeartbeats 0 in
/-
Helper lemma for Lemma 2 Part 1: A product inequality involving factorials/ranges.
-/
lemma lemma2_part1_bound (y : ℕ) (hy : y ≥ 5) :
  ∏ i ∈ Finset.Icc (2 * y + 1) (3 * y), i ≥ 2 * y * ∏ i ∈ Finset.Icc (y + 1) (2 * y), i := by
    -- By induction on $y$, we can show that the inequality holds for all $y \geq 5$.
    induction' y, Nat.succ_le.mpr hy using Nat.le_induction with y ih;
    · decide +kernel;
    · -- Let's simplify the goal using the induction hypothesis.
      have h_simp : (∏ i ∈ Finset.Icc (2 * y + 3) (3 * y + 3), i) = (∏ i ∈ Finset.Icc (2 * y + 1) (3 * y), i) * ((3 * y + 1) * (3 * y + 2) * (3 * y + 3)) / ((2 * y + 1) * (2 * y + 2)) := by
        have h_simp : (∏ i ∈ Finset.Icc (2 * y + 3) (3 * y + 3), i) = (∏ i ∈ Finset.Icc (2 * y + 1) (3 * y + 3), i) / ((2 * y + 1) * (2 * y + 2)) := by
          erw [ Finset.prod_Ico_eq_prod_range, Finset.prod_Ico_eq_prod_range ];
          rw [ Nat.div_eq_of_eq_mul_left ];
          · positivity;
          · rw [ show 3 * y + 3 + 1 - ( 2 * y + 1 ) = ( 3 * y + 3 + 1 - ( 2 * y + 3 ) ) + 2 by omega, Finset.prod_range_succ', Finset.prod_range_succ' ] ; norm_num ; ring_nf;
        rw [ h_simp ];
        erw [ Finset.prod_Ico_eq_prod_range, Finset.prod_Ico_eq_prod_range ] ; norm_num [ add_assoc, mul_assoc, Finset.prod_range_succ ] ; ring_nf;
        rw [ show 4 + y * 3 - ( 1 + y * 2 ) = ( 1 + y * 3 - ( 1 + y * 2 ) ) + 3 by rw [ Nat.sub_eq_of_eq_add ] ; linarith [ Nat.sub_add_cancel ( by linarith : 1 + y * 3 ≥ 1 + y * 2 ) ] ] ; norm_num [ Finset.prod_range_succ ] ; ring_nf;
        rw [ show 1 + y * 3 - ( 1 + y * 2 ) = y by rw [ Nat.sub_eq_of_eq_add ] ; ring ] ; ring_nf;
      -- Let's simplify the right-hand side of the inequality.
      have h_rhs : (∏ i ∈ Finset.Icc (y + 2) (2 * y + 2), i) = (∏ i ∈ Finset.Icc (y + 1) (2 * y), i) * ((2 * y + 1) * (2 * y + 2)) / (y + 1) := by
        erw [ Finset.prod_Ico_eq_prod_range, Finset.prod_Ico_eq_prod_range ];
        rw [ show 2 * y + 2 + 1 - ( y + 2 ) = y + 1 by rw [ Nat.sub_eq_of_eq_add ] ; ring, show 2 * y + 1 - ( y + 1 ) = y by rw [ Nat.sub_eq_of_eq_add ] ; ring ] ; norm_num [ Finset.prod_range_succ ] ; ring_nf;
        rw [ Nat.div_eq_of_eq_mul_left ] <;> try linarith;
        have := Finset.prod_range_succ' ( fun x => 1 + y + x ) y; have := Finset.prod_range_succ' ( fun x => 2 + y + x ) y; norm_num [ add_comm, add_left_comm, add_assoc, Finset.prod_range_succ ] at * ; nlinarith;
      -- Substitute the simplified forms into the inequality.
      have h_subst : (∏ i ∈ Finset.Icc (2 * y + 1) (3 * y), i) * ((3 * y + 1) * (3 * y + 2) * (3 * y + 3)) / ((2 * y + 1) * (2 * y + 2)) ≥ 2 * (y + 1) * ((∏ i ∈ Finset.Icc (y + 1) (2 * y), i) * ((2 * y + 1) * (2 * y + 2)) / (y + 1)) := by
        refine Nat.le_div_iff_mul_le ( by positivity ) |>.2 ?_;
        rw [ ← Nat.mul_div_assoc ];
        · rw [ show 2 * ( y + 1 ) * ( ( ∏ i ∈ Finset.Icc ( y + 1 ) ( 2 * y ), i ) * ( ( 2 * y + 1 ) * ( 2 * y + 2 ) ) ) / ( y + 1 ) = 2 * ( ( ∏ i ∈ Finset.Icc ( y + 1 ) ( 2 * y ), i ) * ( ( 2 * y + 1 ) * ( 2 * y + 2 ) ) ) by rw [ Nat.div_eq_of_eq_mul_left ] <;> linarith ];
          have := ‹y ≥ 5 → ∏ i ∈ Finset.Icc ( 2 * y + 1 ) ( 3 * y ), i ≥ 2 * y * ∏ i ∈ Finset.Icc ( y + 1 ) ( 2 * y ), i› ih;
          nlinarith [ Nat.zero_le ( ∏ i ∈ Finset.Icc ( y + 1 ) ( 2 * y ), i ), Nat.zero_le ( ( 2 * y + 1 ) * ( 2 * y + 2 ) ), Nat.zero_le ( ( 3 * y + 1 ) * ( 3 * y + 2 ) * ( 3 * y + 3 ) ), mul_le_mul_left' ih ( ∏ i ∈ Finset.Icc ( y + 1 ) ( 2 * y ), i ), mul_le_mul_left' ih ( ( 2 * y + 1 ) * ( 2 * y + 2 ) ), mul_le_mul_left' ih ( ( 3 * y + 1 ) * ( 3 * y + 2 ) * ( 3 * y + 3 ) ) ];
        · exact dvd_mul_of_dvd_left ( Finset.dvd_prod_of_mem _ ( Finset.mem_Icc.mpr ⟨ by linarith, by linarith ⟩ ) ) _;
      convert h_subst using 1 ; ring_nf at * ; aesop;

/-
Lemma 2 Part 1: For $y \ge 5$ and $n \ge 4y$, $\binom{n}{2y} \ge 2y \binom{n}{y}$.
-/
lemma lemma2_part1 (n y : ℕ) (hy : y ≥ 5) (hn : n ≥ 4 * y) :
    Nat.choose n (2 * y) ≥ 2 * y * Nat.choose n y := by
      -- We expand the binomial coefficients: $\binom{n}{2y} = \frac{n!}{(2y)!(n-2y)!}$ and $\binom{n}{y} = \frac{n!}{y!(n-y)!}$.
      have h_expand : Nat.choose n (2 * y) = Nat.choose n y * (∏ i ∈ Finset.range y, (n - y - i)) / (∏ i ∈ Finset.range y, (y + i + 1)) := by
        have h_expand : Nat.choose n (2 * y) = Nat.choose n y * (∏ i ∈ Finset.range y, (n - y - i)) / (∏ i ∈ Finset.range y, (y + i + 1)) := by
          have h_binom : Nat.choose n (2 * y) * (∏ i ∈ Finset.range y, (y + i + 1)) = Nat.choose n y * (∏ i ∈ Finset.range y, (n - y - i)) := by
            have h_binom : Nat.choose n (2 * y) * Nat.factorial (2 * y) = Nat.choose n y * Nat.factorial y * (∏ i ∈ Finset.range y, (n - y - i)) := by
              have h_binom : Nat.descFactorial n (2 * y) = Nat.descFactorial n y * (∏ i ∈ Finset.range y, (n - y - i)) := by
                rw [ Nat.descFactorial_eq_prod_range, Nat.descFactorial_eq_prod_range ];
                convert Finset.prod_range_add _ _ y using 3 <;> ring_nf;
                rw [ Nat.sub_sub ];
              rw [ Nat.descFactorial_eq_factorial_mul_choose, Nat.descFactorial_eq_factorial_mul_choose ] at h_binom ; nlinarith [ Nat.factorial_pos y, Nat.factorial_pos ( 2 * y ) ] ;
            have h_factorial : Nat.factorial (2 * y) = Nat.factorial y * (∏ i ∈ Finset.range y, (y + i + 1)) := by
              have h_factorial_step : ∀ k : ℕ, Nat.factorial (y + k) = Nat.factorial y * (∏ i ∈ Finset.range k, (y + i + 1)) := by
                exact fun k => Nat.recOn k ( by norm_num ) fun k ih => by rw [ Nat.add_succ, Nat.factorial_succ, ih, Finset.prod_range_succ ] ; ring;
              rw [ two_mul, h_factorial_step ];
            nlinarith [ Nat.factorial_pos y ]
          rw [ ← h_binom, Nat.mul_div_cancel _ ( Finset.prod_pos fun _ _ => Nat.succ_pos _ ) ];
        grind;
      -- Canceling $n!$ and rearranging, we need $\frac{(n-y)!}{(n-2y)!} \ge 2y \frac{(2y)!}{y!}$.
      have h_cancel : (∏ i ∈ Finset.range y, (n - y - i)) ≥ 2 * y * (∏ i ∈ Finset.range y, (y + i + 1)) := by
        -- From `lemma2_part1_bound`, we know $\prod_{i=2y+1}^{3y} i \ge 2y \prod_{i=y+1}^{2y} i$.
        have h_prod_bound : (∏ i ∈ Finset.range y, (3 * y - i)) ≥ 2 * y * (∏ i ∈ Finset.range y, (y + i + 1)) := by
          -- By simplifying, we can see that both sides of the inequality are equal.
          have h_simp : (∏ i ∈ Finset.range y, (3 * y - i)) = (∏ i ∈ Finset.Icc (2 * y + 1) (3 * y), i) ∧ (∏ i ∈ Finset.range y, (y + i + 1)) = (∏ i ∈ Finset.Icc (y + 1) (2 * y), i) := by
            constructor <;> erw [ Finset.prod_Ico_eq_prod_range ] <;> norm_num [ two_mul, add_assoc ];
            · rw [ show 3 * y + 1 - ( y + ( y + 1 ) ) = y by rw [ Nat.sub_eq_of_eq_add ] ; ring ] ; rw [ ← Finset.prod_range_reflect ] ; norm_num [ add_comm, add_left_comm, add_assoc ] ;
              exact Finset.prod_congr rfl fun x hx => by cases y <;> norm_num at * ; omega;
            · ac_rfl;
          exact h_simp.left.symm ▸ h_simp.right.symm ▸ lemma2_part1_bound y hy;
        refine le_trans h_prod_bound ?_;
        exact Finset.prod_le_prod' fun i hi => by omega;
      rw [ h_expand, ge_iff_le, Nat.le_div_iff_mul_le ] <;> nlinarith [ Nat.choose_pos ( show y ≤ n by linarith ), show 0 < ∏ i ∈ Finset.range y, ( y + i + 1 ) from Finset.prod_pos fun _ _ => Nat.succ_pos _ ] ;

/-
Lemma 2 Step 1: $\binom{n}{xy} \ge \binom{n}{2y}$.
-/
lemma lemma2_step1 (n x y : ℕ) (hx : x ≥ 2) (hy : y ≥ 1) (hn : n ≥ 2 * x * y) :
    Nat.choose n (x * y) ≥ Nat.choose n (2 * y) := by
      -- Since $x \geq 2$, $xy \geq 2y$. Because $n \ge 2xy$, $xy \le n/2$, so $\binom{n}{xy} \ge \binom{n}{2y}$ by the properties of binomial coefficients.
      have h_xy_le_n_div_2 : x * y ≤ n / 2 := by
        rw [ Nat.le_div_iff_mul_le ] <;> linarith;
      -- By the properties of binomial coefficients, $\binom{n}{k}$ is increasing for $k \le n/2$.
      have h_binom_inc : ∀ k l : ℕ, 0 ≤ k → k ≤ l → l ≤ n / 2 → Nat.choose n k ≤ Nat.choose n l := by
        intros k l hk hl hn_div_2
        induction' hl with l hl ih;
        · rfl;
        · exact le_trans ( ih ( Nat.le_of_succ_le hn_div_2 ) ) ( Nat.choose_le_succ_of_lt_half_left ( by linarith [ Nat.div_mul_le_self n 2 ] ) );
      exact h_binom_inc _ _ ( by positivity ) ( by nlinarith ) h_xy_le_n_div_2

/-
Lemma 2 Step 3: $y \binom{n}{y} \ge x \binom{n}{x}$ for $1 \le x \le y$ and $n \ge 2y$.
-/
lemma lemma2_step3 (n x y : ℕ) (hy : y ≥ x) (hn : n ≥ 2 * y) :
    y * Nat.choose n y ≥ x * Nat.choose n x := by
      -- By induction on $y - x$, we can show that $y \binom{n}{y} \ge x \binom{n}{x}$ for all $x \leq y$.
      have h_ind : ∀ k : ℕ, x ≤ k → k ≤ y → k * Nat.choose n k ≥ x * Nat.choose n x := by
        -- We proceed by induction on $k$.
        intro k hkx hky
        induction' hkx with k hk ih;
        · rfl;
        · -- By the properties of binomial coefficients, we have $\frac{(k+1)\binom{n}{k+1}}{k\binom{n}{k}} = \frac{n-k}{k} \ge 1$.
          have h_ratio : (k + 1) * Nat.choose n (k + 1) ≥ k * Nat.choose n k := by
            nlinarith [ Nat.succ_mul_choose_eq n k, Nat.choose_succ_succ n k, show n ≥ 2 * ( k + 1 ) by linarith ];
          exact le_trans ( ih ( Nat.le_of_succ_le hky ) ) h_ratio;
      exact h_ind y hy le_rfl

/-
Lemma 2 (Large y): If $y \ge 5$, then $\binom{n}{xy} \ge x \binom{n}{x} + y\binom{n}{y}.$
-/
lemma lemma2_large_y (n x y : ℕ) (hx : x ≥ 2) (hy : y ≥ x) (hn : n ≥ 2 * x * y) (hy5 : y ≥ 5) :
    Nat.choose n (x * y) ≥ x * Nat.choose n x + y * Nat.choose n y := by
  have hn4y : n ≥ 4 * y := by
    calc n ≥ 2 * x * y := hn
         _ ≥ 2 * 2 * y := by gcongr
         _ = 4 * y := by ring
  have h1 : Nat.choose n (x * y) ≥ Nat.choose n (2 * y) := lemma2_step1 n x y hx (by linarith) hn
  have h2 : Nat.choose n (2 * y) ≥ 2 * y * Nat.choose n y := lemma2_part1 n y hy5 hn4y
  have h3 : y * Nat.choose n y ≥ x * Nat.choose n x := lemma2_step3 n x y (by linarith) (by linarith)
  have h4 : 2 * y * Nat.choose n y = y * Nat.choose n y + y * Nat.choose n y := by ring
  rw [h4] at h2
  have h5 : y * Nat.choose n y + y * Nat.choose n y ≥ x * Nat.choose n x + y * Nat.choose n y := by gcongr
  exact le_trans (le_trans h5 h2) h1

/-
Lemma 2 Case (2,3): For $n \ge 12$, $\binom{n}{6} \ge 2\binom{n}{2} + 3\binom{n}{3}$.
-/
lemma lemma2_case_2_3 (n : ℕ) (hn : n ≥ 12) :
    Nat.choose n 6 ≥ 2 * Nat.choose n 2 + 3 * Nat.choose n 3 := by
      induction hn <;> simp +arith +decide [ Nat.choose ] at *;
      rename_i k hk ih;
      rcases k with ( _ | _ | _ | _ | _ | _ | _ | k ) <;> simp +arith +decide [ Nat.choose ] at *;
      grind

/-
Lemma 2 Case (3,3): For $n \ge 18$, $\binom{n}{9} \ge 6\binom{n}{3}$.
-/
lemma lemma2_case_3_3 (n : ℕ) (hn : n ≥ 18) :
    Nat.choose n 9 ≥ 6 * Nat.choose n 3 := by
      rcases n with ( _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | n ) <;> simp_all +arith +decide [ Nat.choose ];
      exact le_add_of_le_of_nonneg ( le_add_of_le_of_nonneg ( le_add_of_le_of_nonneg ( le_add_of_le_of_nonneg ( le_add_of_le_of_nonneg ( le_add_of_le_of_nonneg ( by exact Nat.le_induction ( by decide ) ( fun k hk ih ↦ by norm_num [ Nat.choose ] at * ; linarith ) _ hn ) ( by norm_num ) ) ( by norm_num ) ) ( by norm_num ) ) ( by norm_num ) ) ( by norm_num ) ) ( by norm_num )

/-
Lemma 2 Case (2,4): For $n \ge 16$, $\binom{n}{8} \ge 2\binom{n}{2} + 4\binom{n}{4}$.
-/
lemma lemma2_case_2_4 (n : ℕ) (hn : n ≥ 16) :
    Nat.choose n 8 ≥ 2 * Nat.choose n 2 + 4 * Nat.choose n 4 := by
      induction' hn with k hk <;> simp +arith +decide [ Nat.choose ] at *;
      rcases k with ( _ | _ | _ | _ | _ | _ | _ | k ) <;> simp +arith +decide [ Nat.choose ] at *;
      rcases k with ( _ | _ | _ | _ | _ | _ | _ | k ) <;> simp +arith +decide [ Nat.choose ] at *

/-
Lemma 2 Case (3,4): For $n \ge 24$, $\binom{n}{12} \ge 3\binom{n}{3} + 4\binom{n}{4}$.
-/
lemma lemma2_case_3_4 (n : ℕ) (hn : n ≥ 24) :
    Nat.choose n 12 ≥ 3 * Nat.choose n 3 + 4 * Nat.choose n 4 := by
      induction' hn with k hk;
      · decide +revert;
      · rcases k with ( _ | _ | _ | _ | _ | _ | _ | _ | _ | k ) <;> simp +arith +decide [ Nat.choose ] at *;
        rcases k with ( _ | _ | _ | _ | _ | _ | _ | k ) <;> simp +arith +decide [ Nat.choose ] at *;
        grind

/-
Lemma 2 Case (4,4): For $n \ge 32$, $\binom{n}{16} \ge 8\binom{n}{4}$.
-/
lemma lemma2_case_4_4 (n : ℕ) (hn : n ≥ 32) :
    Nat.choose n 16 ≥ 8 * Nat.choose n 4 := by
      induction' hn with k hk ih48;
      · decide +revert;
      · have := Nat.succ_mul_choose_eq k 3; have := Nat.succ_mul_choose_eq k 4; have := Nat.succ_mul_choose_eq k 14; have := Nat.succ_mul_choose_eq k 15; norm_num [ Nat.choose ] at * ; nlinarith;

/-
Lemma 2 (Small y): If $y < 5$, then $\binom{n}{xy} \ge x \binom{n}{x} + y\binom{n}{y}$ with the given exceptions.
-/
lemma lemma2_small_y (n x y : ℕ) (hx : x ≥ 2) (hy : y ≥ x) (hn : n ≥ 2 * x * y)
  (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) (hy_lt_5 : y < 5) :
  Nat.choose n (x * y) ≥ x * Nat.choose n x + y * Nat.choose n y := by
    interval_cases y <;> interval_cases x <;> simp_all +arith +decide only;
    · rcases n with ( _ | _ | _ | _ | _ | _ | _ | _ | n ) <;> simp +arith +decide [ Nat.choose ] at *;
      rcases n with ( _ | _ | _ | _ | _ | _ | _ | _ | n ) <;> simp +arith +decide [ Nat.choose ] at *;
      · exact h_not_prime_pow 2 3 Nat.prime_two rfl;
      · exact h_not_prime_pow 3 2 ( by norm_num ) rfl;
    · exact lemma2_case_2_3 n hn;
    · exact lemma2_case_3_3 n hn;
    · exact lemma2_case_2_4 n hn;
    · exact lemma2_case_3_4 n hn
    · exact lemma2_case_4_4 n hn

/-
Lemma 2: If $y\ge x \ge 2$, and $n \ge 2xy$, then with the exceptions from $x=y=2$ and $n \in\{8,9\}$, $\binom{n}{xy} \ge x \binom{n}{x} + y\binom{n}{y}.$
-/
lemma lemma2 (n x y : ℕ) (hx : x ≥ 2) (hy : y ≥ x) (hn : n ≥ 2 * x * y)
  (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) :
  Nat.choose n (x * y) ≥ x * Nat.choose n x + y * Nat.choose n y := by
    -- Consider two cases: $y < 5$ and $y \geq 5$.
    by_cases hy_lt_5 : y < 5;
    · exact lemma2_small_y n x y hx hy hn h_not_prime_pow hy_lt_5;
    · convert lemma2_large_y n x y hx hy hn ( by linarith ) using 1

/-
Define K(n) as the sum used in the target formula.
-/
noncomputable def K (n : ℕ) : ℕ :=
  Finset.sum n.factorization.support fun p =>
    (Finset.sum (Finset.Icc 1 (n.factorization p)) fun d => Nat.choose n (p ^ d)) * (p - 1)

/-
Lemma 1 Lucas Step: If $v_p(n) \ge j$, then $v_p(\binom{n-1}{p^j-1}) = 0$.
-/
lemma lemma1_lucas_step (n j p : ℕ) (hp : p.Prime) (hj : j ≥ 1) (hjn : j ≤ padicValNat p n) :
    padicValNat p (Nat.choose (n - 1) (p ^ j - 1)) = 0 := by
  -- We use Lucas's Theorem: choose n k ≡ ∏ i ∈ range a, choose (n / p ^ i % p) (k / p ^ i % p) [ZMOD p]
  -- Here, we want to show that choose (n - 1) (p ^ j - 1) is not divisible by p.
  -- This is equivalent to showing choose (n - 1) (p ^ j - 1) ≡ 1 [MOD p] or at least non-zero.
  -- Let a = j. Since p^j | n, n = m * p^j.
  -- n - 1 = m * p^j - 1 = (m - 1) * p^j + (p^j - 1).
  -- p^j - 1 = \sum_{k=0}^{j-1} (p-1) p^k.
  -- So the first j digits of n-1 in base p are all p-1.
  -- The first j digits of p^j - 1 in base p are also all p-1.
  -- Thus choose (n - 1) (p ^ j - 1) ≡ \prod_{k=0}^{j-1} choose (p-1) (p-1) ≡ 1 [MOD p].
  -- This means the first $j$ digits of $n-1$ in base $p$ are all $p-1$.
  have h_digits : ∀ k ∈ Finset.range j, (n - 1) / p ^ k % p = p - 1 := by
    -- Since $p^j \mid n$, we have $n = p^j * m$ for some integer $m$.
    obtain ⟨m, hm⟩ : ∃ m, n = p ^ j * m := by
      refine' Nat.dvd_trans ( pow_dvd_pow _ hjn ) _;
      exact pow_padicValNat_dvd;
    -- Since $p^j \mid n$, we have $(p^j * m - 1) / p^k = p^{j-k} * m - 1 / p^k$.
    have h_div : ∀ k ∈ Finset.range j, (p ^ j * m - 1) / p ^ k = p ^ (j - k) * m - 1 := by
      intro k hk; rw [ show p ^ j * m = p ^ k * ( p ^ ( j - k ) * m ) by rw [ ← mul_assoc, ← pow_add, add_tsub_cancel_of_le ( Finset.mem_range_le hk ) ] ] ;
      cases h : p ^ ( j - k ) * m <;> simp_all +decide [ Nat.mul_succ ];
      exact Nat.le_antisymm ( Nat.le_of_lt_succ <| Nat.div_lt_of_lt_mul <| by rw [ tsub_lt_iff_left ] <;> nlinarith [ pow_pos hp.pos k ] ) ( Nat.le_div_iff_mul_le ( pow_pos hp.pos k ) |>.2 <| Nat.le_sub_one_of_lt <| by nlinarith [ pow_pos hp.pos k ] );
    rcases p with ( _ | _ | p ) <;> simp_all +decide [ ← ZMod.val_natCast ];
    intro k hk; rw [ Nat.cast_sub <| Nat.one_le_iff_ne_zero.mpr <| mul_ne_zero ( pow_ne_zero _ <| Nat.succ_ne_zero _ ) <| by aesop_cat ] ; simp +decide [ Nat.succ_eq_add_one ] ;
    norm_num [ zero_pow ( Nat.sub_ne_zero_of_lt hk ) ];
  -- By Lucas's Theorem, $\binom{n-1}{p^j-1} \equiv \prod_{k=0}^{j-1} \binom{p-1}{p-1} \pmod p$.
  have h_lucas : Nat.choose (n - 1) (p ^ j - 1) ≡ 1 [MOD p] := by
    have h_lucas : ∀ (a b : ℕ), a ≤ n - 1 → b ≤ p ^ j - 1 → Nat.choose a b ≡ Nat.choose (a % p) (b % p) * Nat.choose (a / p) (b / p) [MOD p] := by
      haveI := Fact.mk hp; simp +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
      -- Apply Lucas's Theorem to conclude the proof.
      have h_lucas : ∀ (a b : ℕ), Nat.choose a b ≡ Nat.choose (a % p) (b % p) * Nat.choose (a / p) (b / p) [MOD p] := by
        exact fun a b => Choose.choose_modEq_choose_mod_mul_choose_div_nat;
      exact fun a b ha hb => by simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_lucas a b;
    -- Applying Lucas's Theorem iteratively, we can reduce the problem to showing that $\binom{p-1}{p-1} \equiv 1 \pmod{p}$ for each $k$.
    have h_lucas_iter : ∀ k ∈ Finset.range j, Nat.choose ((n - 1) / p ^ k) (p ^ (j - k) - 1) ≡ Nat.choose ((n - 1) / p ^ (k + 1)) (p ^ (j - k - 1) - 1) [MOD p] := by
      intros k hk
      have h_lucas_iter_step : Nat.choose ((n - 1) / p ^ k) (p ^ (j - k) - 1) ≡ Nat.choose ((n - 1) / p ^ k % p) (p - 1) * Nat.choose ((n - 1) / p ^ (k + 1)) (p ^ (j - k - 1) - 1) [MOD p] := by
        convert h_lucas _ _ _ _ using 1;
        · rw [ show p ^ ( j - k ) - 1 = p * ( p ^ ( j - k - 1 ) - 1 ) + ( p - 1 ) from ?_, Nat.add_div ] <;> norm_num [ hp.pos ];
          · rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.div_div_eq_div_mul, pow_succ' ];
            norm_num [ Nat.div_eq_of_lt, mul_comm ];
          · rw [ Nat.mul_sub_left_distrib, mul_one, ← pow_succ', Nat.sub_add_cancel ( Nat.sub_pos_of_lt ( Finset.mem_range.mp hk ) ) ];
            rw [ tsub_add_tsub_cancel ( Nat.le_self_pow ( Nat.sub_ne_zero_of_lt ( Finset.mem_range.mp hk ) ) _ ) hp.pos ];
        · exact Nat.div_le_self _ _;
        · exact Nat.sub_le_sub_right ( pow_le_pow_right₀ hp.one_lt.le ( Nat.sub_le _ _ ) ) _;
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
    have h_lucas_iter_start : ∀ k ∈ Finset.range j, Nat.choose ((n - 1) / p ^ 0) (p ^ j - 1) ≡ Nat.choose ((n - 1) / p ^ (k + 1)) (p ^ (j - k - 1) - 1) [MOD p] := by
      intro k hk;
      induction' k with k ih;
      · simpa using h_lucas_iter 0 hk;
      · exact Eq.trans ( ih ( Finset.mem_range.mpr ( Nat.lt_of_succ_lt ( Finset.mem_range.mp hk ) ) ) ) ( h_lucas_iter ( k + 1 ) hk ) |> Eq.trans <| by simp +decide [ Nat.sub_sub ] ;
    specialize h_lucas_iter_start ( j - 1 ) ; rcases j <;> aesop;
  haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
  exact Or.inr <| Or.inr <| by rw [ ← ZMod.natCast_eq_zero_iff ] ; aesop;

/-
Lemma 1 Equality: If $v_p(n) \ge j$, then $v_p(\binom{n}{p^j}) = v_p(n) - j$.
-/
lemma lemma1_equality (n j p : ℕ) (hp : p.Prime) (hj : j ≥ 1) (hjn : j ≤ padicValNat p n) :
    padicValNat p (Nat.choose n (p ^ j)) = padicValNat p n - j := by
      have h_div : padicValNat p (Nat.choose n (p ^ j)) = padicValNat p (n / (p ^ j) * Nat.choose (n - 1) (p ^ j - 1)) := by
        have h_div : Nat.choose n (p ^ j) * (p ^ j) = n * Nat.choose (n - 1) (p ^ j - 1) := by
          cases n <;> cases p <;> cases j <;> simp_all +decide [ Nat.succ_mul_choose_eq ];
          rw [ Nat.sub_add_cancel ( Nat.one_le_pow _ _ ( Nat.succ_pos _ ) ) ];
        have h_div : Nat.choose n (p ^ j) = (n / p ^ j) * Nat.choose (n - 1) (p ^ j - 1) := by
          have h_div : p ^ j ∣ n := by
            have h_div : p ^ (padicValNat p n) ∣ n := by
              convert Nat.ordProj_dvd n p using 1;
              rw [ Nat.factorization ] ; aesop;
            exact dvd_trans ( pow_dvd_pow _ ‹_› ) h_div;
          nlinarith [ Nat.div_mul_cancel h_div, pow_pos hp.pos j ];
        rw [h_div];
      have h_div : padicValNat p (n / p ^ j * Nat.choose (n - 1) (p ^ j - 1)) = padicValNat p (n / p ^ j) + padicValNat p (Nat.choose (n - 1) (p ^ j - 1)) := by
        convert padicValNat.mul _ _ using 1;
        · exact ⟨ hp ⟩;
        · refine' Nat.ne_of_gt ( Nat.div_pos _ ( pow_pos hp.pos _ ) );
          have h_div : p ^ j ∣ n := by
            have h_div : p ^ padicValNat p n ∣ n := by
              exact pow_padicValNat_dvd;
            exact dvd_trans ( pow_dvd_pow _ ‹_› ) h_div;
          apply Nat.le_of_dvd (Nat.pos_of_ne_zero (by
          aesop)) h_div;
        · refine' Nat.ne_of_gt ( Nat.choose_pos _ );
          gcongr;
          have := Nat.ordProj_dvd n p;
          exact Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ( dvd_trans ( pow_dvd_pow _ ( by linarith! [ show n.factorization p = padicValNat p n from by rw [ Nat.factorization_def ] ; aesop_cat ] ) ) this );
      have h_div : padicValNat p (n / p ^ j) = padicValNat p n - j := by
        have h_div : padicValNat p (n / p ^ j) = padicValNat p n - padicValNat p (p ^ j) := by
          have h_div : padicValNat p (n / p ^ j) = padicValNat p n - padicValNat p (p ^ j) := by
            have h_div : p ^ j ∣ n := by
              have h_div : p ^ (padicValNat p n) ∣ n := by
                convert Nat.ordProj_dvd n p using 1;
                rw [ Nat.factorization ] ; aesop;
              exact dvd_trans ( pow_dvd_pow _ ‹_› ) h_div
            have h_div : padicValNat p (n / p ^ j) = padicValNat p n - padicValNat p (p ^ j) := by
              have h_div : n = p ^ j * (n / p ^ j) := by
                rw [ Nat.mul_div_cancel' h_div ]
              have h_div : padicValNat p (p ^ j * (n / p ^ j)) = padicValNat p (p ^ j) + padicValNat p (n / p ^ j) := by
                convert padicValNat.mul _ _ using 1
                generalize_proofs at *; (
                exact ⟨ hp ⟩);
                · exact pow_ne_zero _ hp.ne_zero;
                · intro h; simp_all +singlePass ;
              generalize_proofs at *; (
              grind)
            generalize_proofs at *; (
            exact h_div)
          generalize_proofs at *;
          exact h_div;
        haveI := Fact.mk hp; rw [ h_div, padicValNat.pow ] ; aesop;
        exact hp.ne_zero;
      have h_div : padicValNat p (Nat.choose (n - 1) (p ^ j - 1)) = 0 := by
        exact lemma1_lucas_step n j p hp hj hjn;
      linarith [ Nat.sub_add_cancel hjn ]

/-
We define the set of generators as the binomial coefficients $\binom{n}{i}$ for $1 \le i < n$, cast to integers.
We define `Representable` as the additive submonoid generated by these integers (i.e., all non-negative integer linear combinations).
-/
def generators_int (n : ℕ) : Set ℤ :=
  Int.ofNat '' (generators n)

def Representable (n : ℕ) : AddSubmonoid ℤ :=
  AddSubmonoid.closure (generators_int n)

lemma lemma_super_increasing (n : ℕ) (p : ℕ) (j : ℕ)
    (hp : p ∈ n.factorization.support)
    (hj : 1 ≤ j) (hj_lt : j < n.factorization p)
    (h_not_prime_pow : ∀ q k, Nat.Prime q → n ≠ q ^ k) :
    (Nat.choose n (p ^ (j + 1)) : ℤ) > (p - 1) * ∑ k ∈ Finset.Icc 1 j, (Nat.choose n (p ^ k) : ℤ) := by
      -- By induction on $j$, we can show that the inequality holds for all $j$.
      have h_ind : ∀ j : ℕ, 1 ≤ j → j < Nat.factorization n p → (Nat.choose n (p ^ (j + 1)) : ℤ) > (p - 1) * (∑ k ∈ Finset.Icc 1 j, (Nat.choose n (p ^ k) : ℤ)) := by
        intro j hj hj_lt
        induction' hj with j hj ih;
        · -- By Lemma 2, we have $\binom{n}{p^2} \ge p \binom{n}{p}$.
          have h_lemma2 : (Nat.choose n (p ^ 2) : ℤ) ≥ p * (Nat.choose n p : ℤ) := by
            have h_lemma2 : (Nat.choose n (p ^ 2) : ℤ) ≥ p * (Nat.choose n p : ℤ) := by
              have h_lemma2_step : ∀ x y : ℕ, 2 ≤ x → x ≤ y → 2 * x * y ≤ n → (Nat.choose n (x * y) : ℤ) ≥ x * (Nat.choose n x : ℤ) + y * (Nat.choose n y : ℤ) := by
                intros x y hx hy hn
                apply Int.ofNat_le.mpr
                apply lemma2 n x y hx hy hn
                intro q k hq hn_eq_qk
                apply h_not_prime_pow q k hq hn_eq_qk
              by_cases hp_ge_2 : 2 ≤ p;
              · have h_lemma2_step : 2 * p * p ≤ n := by
                  have h_lemma2_step : p ^ 2 ∣ n := by
                    exact dvd_trans ( pow_dvd_pow _ hj_lt ) ( Nat.ordProj_dvd _ _ );
                  obtain ⟨ k, hk ⟩ := h_lemma2_step;
                  rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.pow_succ', mul_assoc ];
                  · exact h_not_prime_pow p 2 hp.1 ( by ring );
                  · nlinarith only [ hp_ge_2, mul_le_mul_left' hp_ge_2 p ];
                simp_all +decide [ sq ];
                grind;
              · interval_cases p <;> simp_all +decide
            exact h_lemma2;
          rcases p with ( _ | _ | p ) <;> norm_num at *;
          nlinarith [ Nat.choose_pos ( show p + 1 + 1 ≤ n from Nat.le_of_dvd ( Nat.pos_of_ne_zero hp.2.2 ) hp.2.1 ) ];
        · -- By Lemma 2, we have $\binom{n}{p^{j+1}} \ge (p-1)\binom{n}{p^j} + \binom{n}{p^{j+1}}$.
          have h_lemma2 : (Nat.choose n (p ^ (j + 2)) : ℤ) ≥ (p - 1) * (Nat.choose n (p ^ (j + 1)) : ℤ) + (Nat.choose n (p ^ (j + 1)) : ℤ) := by
            -- Since $p^{j+1} \geq 5$, we can apply Lemma 2 with $x = p$ and $y = p^{j+1}$.
            have h_lemma2 : (Nat.choose n (p * p ^ (j + 1)) : ℤ) ≥ p * (Nat.choose n p : ℤ) + p ^ (j + 1) * (Nat.choose n (p ^ (j + 1)) : ℤ) := by
              have h_lemma2 : ∀ x y : ℕ, 2 ≤ x → x ≤ y → 2 * x * y ≤ n → (Nat.choose n (x * y) : ℤ) ≥ x * (Nat.choose n x : ℤ) + y * (Nat.choose n y : ℤ) := by
                intros x y hx hy hn; exact_mod_cast lemma2 n x y hx hy hn ( fun q k hq => h_not_prime_pow q k hq ) ;
              convert h_lemma2 p ( p ^ ( j + 1 ) ) _ _ _ using 1 <;> norm_num;
              · exact Nat.Prime.two_le ( Nat.prime_of_mem_primeFactors hp );
              · exact Nat.le_self_pow ( by linarith ) _;
              · have h_div : p ^ (j + 2) ∣ n := by
                  exact Nat.dvd_trans ( pow_dvd_pow _ hj_lt ) ( Nat.ordProj_dvd _ _ );
                obtain ⟨ k, hk ⟩ := h_div;
                rcases k with ( _ | _ | k ) <;> simp_all +decide [ pow_succ' ];
                · exact False.elim ( h_not_prime_pow p ( j + 2 ) hp.1 ( by ring ) );
                · grind;
            simp_all +decide [ pow_succ' ];
            nlinarith [ Nat.Prime.one_lt hp.1, pow_le_pow_right₀ hp.1.one_lt.le hj, pow_pos hp.1.pos j, pow_pos hp.1.pos ( j + 1 ), Nat.choose_pos ( show p ≤ n from Nat.le_of_dvd ( Nat.pos_of_ne_zero hp.2.2 ) hp.2.1 ) ];
          simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ];
          grind;
      -- Apply the induction hypothesis with the given j.
      apply h_ind j hj hj_lt

/-
If the valuation of an integer $n$ is $k+1$, then the valuation of $n/p$ is $k$.
-/
lemma lemma_val_div_int (p : ℕ) (n : ℤ) (k : ℕ) (hp : p.Prime) (h_val : padicValNat p n.toNat = k + 1) :
    padicValNat p (n / p).toNat = k := by
      have h_div : Int.toNat (n / p) = Int.toNat n / p := by
        cases n <;> aesop;
      haveI := Fact.mk hp; rw [ h_div, padicValNat.div_of_dvd ] ; aesop;
      exact ( by contrapose! h_val; simp_all +decide [ padicValNat.eq_zero_of_not_dvd ] )

/-
If the highest coefficient matches p-1, we can reduce the congruence by dividing by p.
-/
lemma lemma_reduction_step (p e : ℕ) (A : ℕ → ℤ) (c : ℕ → ℤ)
    (hp : p.Prime)
    (he : e ≥ 2)
    (h_val : ∀ j ∈ Finset.Icc 1 e, padicValNat p (A j).toNat = e - j)
    (hc_e : c e = p - 1)
    (h_cong : ∑ j ∈ Finset.Icc 1 e, c j * A j ≡ ∑ j ∈ Finset.Icc 1 e, (p - 1) * A j [ZMOD p ^ e]) :
    ∑ j ∈ Finset.Icc 1 (e - 1), c j * (A j / p) ≡ ∑ j ∈ Finset.Icc 1 (e - 1), (p - 1) * (A j / p) [ZMOD p ^ (e - 1)] := by
      -- Since $A_j / p$ is an integer for $j \in \text{Icc}(1, e-1)$, we can rewrite the sums modulo $p^{e-1}$.
      have h_sum_div : (∑ j ∈ Finset.Icc 1 (e - 1), c j * A j) ≡ (∑ j ∈ Finset.Icc 1 (e - 1), (p - 1) * A j) [ZMOD p ^ e] := by
        rcases e <;> simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ];
        (expose_names; exact Int.ModEq.add_right_cancel' ((↑p - 1) * A (n + 1)) h_cong);
      -- Since $A_j / p$ is an integer for $j \in \text{Icc}(1, e-1)$, we can rewrite the sums modulo $p^{e-1}$ by dividing both sides of the congruence by $p$.
      have h_sum_div_div : (∑ j ∈ Finset.Icc 1 (e - 1), c j * (A j / p)) * p ≡ (∑ j ∈ Finset.Icc 1 (e - 1), (p - 1) * (A j / p)) * p [ZMOD p ^ e] := by
        have h_sum_div_p : ∀ j ∈ Finset.Icc 1 (e - 1), A j = (A j / p) * p := by
          intros j hj
          have h_div : (p : ℤ) ∣ A j := by
            have := h_val j ( Finset.mem_Icc.mpr ⟨ Finset.mem_Icc.mp hj |>.1, Nat.le_trans ( Finset.mem_Icc.mp hj |>.2 ) ( Nat.pred_le _ ) ⟩ ) ; contrapose! this; simp_all +decide
            rcases k : A j with ( _ | _ | k ) <;> simp_all +decide
            · rw [ padicValNat.eq_zero_of_not_dvd ] <;> norm_cast at * ; omega;
            · omega;
            · omega
          exact Eq.symm (Int.ediv_mul_cancel h_div);
        convert h_sum_div using 1 <;> rw [ Finset.sum_mul _ _ _ ] <;> rw [ Finset.sum_congr rfl ] <;> intros <;> rw [ h_sum_div_p _ ‹_› ] <;> ring_nf;
        · rw [ Int.mul_ediv_cancel _ ( Nat.cast_ne_zero.mpr hp.ne_zero ) ] ; ring;
        · rw [ Int.mul_ediv_cancel_left _ ( Nat.cast_ne_zero.mpr hp.ne_zero ) ];
      rcases e with ( _ | _ | e ) <;> simp_all +decide [ Int.modEq_iff_dvd ];
      obtain ⟨ k, hk ⟩ := h_sum_div_div; exact ⟨ k, by { rw [ show ( p : ℤ ) ^ ( e + 1 + 1 ) = ( p : ℤ ) ^ ( e + 1 ) * p by ring ] at hk; nlinarith [ hp.two_le ] } ⟩ ;

/-
A sequence A is a SuperSequence for prime p and length m if:
1. The p-adic valuation of A_j is m-j for 1 <= j <= m.
2. It satisfies the super-increasing property: A_{j+1} > (p-1) * sum_{k=1}^j A_k.
3. All terms are positive.
-/
def IsSuperSequence (p m : ℕ) (A : ℕ → ℤ) : Prop :=
  (∀ j ∈ Finset.Icc 1 m, padicValNat p (A j).toNat = m - j) ∧
  (∀ j, 1 ≤ j → j < m → A (j + 1) > (p - 1) * ∑ k ∈ Finset.Icc 1 j, A k) ∧
  (∀ j ∈ Finset.Icc 1 m, A j > 0)

/-
If A is a SuperSequence of length m, then A/p is a SuperSequence of length m-1.
-/
lemma lemma_super_sequence_step (p m : ℕ) (A : ℕ → ℤ)
    (hp : p.Prime) (hm : m ≥ 2)
    (hA : IsSuperSequence p m A) :
    IsSuperSequence p (m - 1) (fun j => A j / p) := by
      rcases m with ( _ | m ) <;> simp_all +decide [ IsSuperSequence ];
      refine' ⟨ _, _, _ ⟩;
      · intro j hj₁ hj₂; specialize hA; have := hA.1 j hj₁ ( by linarith ) ; simp_all +decide [ Nat.succ_sub ( by linarith : j ≤ m ) ] ;
        exact lemma_val_div_int p (A j) (m - j) hp this;
      · intro j hj₁ hj₂; have := hA.2.1 j hj₁ ( by linarith ) ; rw [ Int.lt_ediv_iff_mul_lt ] at * <;> norm_num [ hp.pos ] at *;
        · -- Since $p \mid A_k$ for $k \le j < m-1$, we can divide both sides of the inequality by $p$.
          have h_div : ∀ k ∈ Finset.Icc 1 j, (A k).toNat % p = 0 := by
            intro k hk; specialize hA; have := hA.1 k ( Finset.mem_Icc.mp hk |>.1 ) ( by linarith [ Finset.mem_Icc.mp hk |>.2 ] ) ; rw [ ← Nat.dvd_iff_mod_eq_zero ] ;
            contrapose! this; simp_all +decide [ padicValNat.eq_zero_of_not_dvd ] ;
            omega;
          have h_div : ∑ k ∈ Finset.Icc 1 j, (A k).toNat = p * ∑ k ∈ Finset.Icc 1 j, (A k).toNat / p := by
            rw [ Finset.mul_sum _ _ _, Finset.sum_congr rfl fun x hx => Nat.mul_div_cancel' <| Nat.dvd_of_mod_eq_zero <| h_div x hx ];
          have h_div : ∑ k ∈ Finset.Icc 1 j, A k = ∑ k ∈ Finset.Icc 1 j, (A k).toNat := by
            rw [ Nat.cast_sum ] ; exact Finset.sum_congr rfl fun x hx => by rw [ Int.toNat_of_nonneg ( le_of_lt ( hA.2.2 x ( Finset.mem_Icc.mp hx |>.1 ) ( by linarith [ Finset.mem_Icc.mp hx |>.2 ] ) ) ) ] ;
          simp_all +decide [ mul_comm, mul_left_comm ];
          convert this using 1;
          exact congrArg _ ( congrArg _ ( Finset.sum_congr rfl fun x hx => by rw [ max_eq_left ( by linarith [ hA.2.2 x ( Finset.mem_Icc.mp hx |>.1 ) ( by linarith [ Finset.mem_Icc.mp hx |>.2 ] ) ] ) ] ) );
        · have := hA.1 ( j + 1 ) ( by linarith ) ( by linarith ) ; simp_all +decide
          have h_div : p ∣ Int.toNat (A (j + 1)) := by
            contrapose! this;
            rw [ padicValNat.eq_zero_of_not_dvd this ] ; omega;
          simpa [ ← Int.natCast_dvd_natCast, Int.toNat_of_nonneg ( le_of_lt ( hA.2.2 ( j + 1 ) ( by linarith ) ( by linarith ) ) ) ] using h_div;
      · intro j hj₁ hj₂; specialize hA; have := hA.2.2 j hj₁ ( by linarith ) ; rw [ Int.lt_ediv_iff_mul_lt ] <;> norm_num [ hp.pos ] ; aesop;
        have h_div : padicValNat p (A j).toNat ≥ 1 := by
          grind
        generalize_proofs at *;
        contrapose! h_div; simp_all +decide [ ← Int.natCast_dvd_natCast ] ;
        exact Or.inr <| Or.inr <| by rwa [ max_eq_left this.le ] ;

/-
Base case for SuperSequence induction: if m=1, the linear combination is greater than or equal to the target.
-/
lemma lemma_super_sequence_base (p : ℕ) (A : ℕ → ℤ) (c : ℕ → ℤ)
    (hp : p.Prime)
    (hA : IsSuperSequence p 1 A)
    (hc_nonneg : ∀ j, 0 ≤ c j)
    (h_cong : c 1 * A 1 ≡ (p - 1) * A 1 [ZMOD p]) :
    c 1 * A 1 ≥ (p - 1) * A 1 := by
      -- From `IsSuperSequence p 1 A`, we have $v_p(A_1) = 1 - 1 = 0$. So $A_1$ is not divisible by $p$.
      have hA1_not_div_p : ¬(p : ℤ) ∣ A 1 := by
        have := hA.1 1 ( by decide );
        contrapose! this; simp_all +decide
        exact ⟨ hp.ne_one, hA.2.2 1 ( by norm_num ), by simpa [ ← Int.natCast_dvd_natCast, Int.toNat_of_nonneg ( hA.2.2 1 ( by norm_num ) |> le_of_lt ) ] using this ⟩;
      -- Since $c_1 \equiv p-1 \pmod p$ and $c_1 \ge 0$, the smallest non-negative integer congruent to $p-1$ modulo $p$ is $p-1$. So $c_1 \ge p-1$.
      have hc1_ge_p_minus_1 : c 1 ≥ p - 1 := by
        have hc1_ge_p_minus_1 : (c 1 : ℤ) ≡ (p - 1 : ℤ) [ZMOD p] := by
          haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
          exact mul_left_cancel₀ ( show ( A 1 : ZMod p ) ≠ 0 from by rw [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] at hA1_not_div_p; aesop ) <| by linear_combination' h_cong;
        exact Int.le_of_not_gt fun h => by have := hc1_ge_p_minus_1.symm.dvd; obtain ⟨ k, hk ⟩ := this; nlinarith [ show k = 0 by nlinarith [ hc_nonneg 1 ] ] ;
      exact mul_le_mul_of_nonneg_right hc1_ge_p_minus_1 ( hA.2.2 1 ( by norm_num ) |> le_of_lt )

/-
For a SuperSequence, the coefficient of the m-th term is congruent to p-1 modulo p.
-/
lemma lemma_abstract_coeff_congruence (p m : ℕ) (A : ℕ → ℤ) (c : ℕ → ℤ)
    (hp : p.Prime) (hm : m ≥ 1)
    (hA : IsSuperSequence p m A)
    (h_cong : ∑ j ∈ Finset.Icc 1 m, c j * A j ≡ ∑ j ∈ Finset.Icc 1 m, (p - 1) * A j [ZMOD p ^ m]) :
    c m ≡ p - 1 [ZMOD p] := by
      -- By definition of SuperSequence, we know that for $j < m$, $v_p(A_j) = m - j \ge 1$, so $A_j \equiv 0 \pmod p$.
      have hA_mod_p : ∀ j ∈ Finset.Icc 1 (m - 1), A j ≡ 0 [ZMOD p] := by
        intro j hj; have := hA.1 j ( Finset.mem_Icc.mpr ⟨ Finset.mem_Icc.mp hj |>.1, Nat.le_trans ( Finset.mem_Icc.mp hj |>.2 ) ( Nat.pred_le _ ) ⟩ ) ; simp_all +decide [ Int.modEq_zero_iff_dvd ] ;
        convert Int.natCast_dvd.mpr ( Nat.dvd_of_mod_eq_zero _ ) using 1;
        rw [ ← Nat.dvd_iff_mod_eq_zero ];
        contrapose! this; simp_all +decide
        cases h : A j <;> simp_all +decide [ padicValNat.eq_zero_of_not_dvd ] ; omega;
        exact ne_of_lt ( Nat.sub_pos_of_lt ( lt_of_le_of_lt hj.2 ( Nat.pred_lt ( ne_bot_of_gt hm ) ) ) );
      -- Since $A_m$ is not divisible by $p$, we can cancel $A_m$ to get $c_m \equiv p-1 \pmod p$.
      have hA_m_not_div_p : ¬(p : ℤ) ∣ A m := by
        have := hA.1 m ( Finset.mem_Icc.mpr ⟨ hm, le_rfl ⟩ );
        rcases k : A m with ( _ | _ | k ) <;> simp_all +decide [ ← Int.natCast_dvd_natCast ];
        · exact this.resolve_left hp.ne_one |> Or.rec ( fun h => by specialize hA; have := hA.2.2 m ( Finset.mem_Icc.mpr ⟨ hm, le_rfl ⟩ ) ; aesop ) fun h => by specialize hA; have := hA.2.2 m ( Finset.mem_Icc.mpr ⟨ hm, le_rfl ⟩ ) ; aesop;
        · exact_mod_cast hp.not_dvd_one;
        · have := hA.2.2 m ( Finset.mem_Icc.mpr ⟨ hm, le_rfl ⟩ ) ; aesop;
      have h_cancel : c m * A m ≡ (p - 1) * A m [ZMOD p] := by
        have h_cancel : ∑ j ∈ Finset.Icc 1 m, c j * A j ≡ ∑ j ∈ Finset.Icc 1 m, (p - 1) * A j [ZMOD p] := by
          exact h_cong.of_dvd <| dvd_pow_self _ <| by linarith;
        have h_cancel : ∑ j ∈ Finset.Icc 1 (m - 1), c j * A j ≡ 0 [ZMOD p] ∧ ∑ j ∈ Finset.Icc 1 (m - 1), (p - 1) * A j ≡ 0 [ZMOD p] := by
          exact ⟨ Int.modEq_zero_iff_dvd.mpr <| Finset.dvd_sum fun x hx => dvd_mul_of_dvd_right ( Int.dvd_of_emod_eq_zero <| hA_mod_p x hx ) _, Int.modEq_zero_iff_dvd.mpr <| Finset.dvd_sum fun x hx => dvd_mul_of_dvd_right ( Int.dvd_of_emod_eq_zero <| hA_mod_p x hx ) _ ⟩;
        rcases m with ( _ | m ) <;> simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ];
        simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
      haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
      exact mul_left_cancel₀ ( show ( A m : ZMod p ) ≠ 0 from by rw [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] at hA_m_not_div_p; aesop ) ( by linear_combination' h_cancel )

/-
If the m-th coefficient is at least 2p-1, the linear combination is strictly greater than the target sum for a SuperSequence.
-/
lemma lemma_abstract_large_coeff_bound (p m : ℕ) (A : ℕ → ℤ) (c : ℕ → ℤ)
    (hp : p.Prime) (hm : m ≥ 1)
    (hA : IsSuperSequence p m A)
    (hc_nonneg : ∀ j, 0 ≤ c j)
    (hc_m : c m ≥ 2 * p - 1) :
    ∑ j ∈ Finset.Icc 1 m, c j * A j > ∑ j ∈ Finset.Icc 1 m, (p - 1) * A j := by
      -- Since $c_m \geq 2p - 1$, we have $c_m - (p - 1) \geq p$.
      have h_diff : (c m - (p - 1)) * (A m) > (p - 1) * (A m) := by
        exact mul_lt_mul_of_pos_right ( by linarith [ hp.two_le ] ) ( hA.2.2 m ( Finset.mem_Icc.mpr ⟨ hm, le_rfl ⟩ ) );
      -- By induction on $j$, we can show that for all $j \in \{1, 2, \ldots, m-1\}$, $c_j * A_j \geq 0$.
      have h_ind : ∀ j ∈ Finset.Icc 1 (m - 1), c j * A j ≥ 0 := by
        exact fun j hj => mul_nonneg ( hc_nonneg j ) ( hA.2.2 j ( Finset.mem_Icc.mpr ⟨ Finset.mem_Icc.mp hj |>.1, Finset.mem_Icc.mp hj |>.2.trans ( Nat.pred_le _ ) ⟩ ) |> le_of_lt );
      rcases m with ( _ | _ | m ) <;> simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ];
      · nlinarith [ hp.two_le, hA.2.2 1 ( by norm_num ) ];
      · have := hA.2.1 ( m + 1 ) ( by linarith ) ( by linarith ) ; simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ] ;
        simp_all +decide [ ← Finset.mul_sum _ _ _ ];
        nlinarith [ hp.two_le, show ∑ k ∈ Finset.Ioc 0 m, c k * A k ≥ 0 from Finset.sum_nonneg fun x hx => h_ind x ( Finset.mem_Ioc.mp hx |>.1 ) ( Finset.mem_Ioc.mp hx |>.2.trans ( Nat.le_succ _ ) ), show c ( m + 1 ) * A ( m + 1 ) ≥ 0 from h_ind ( m + 1 ) ( Nat.succ_pos _ ) ( Nat.le_refl _ ) ]

/-
If the m-th coefficient is p-1, the inequality for the sum reduces to the inequality for the divided sequence.
-/
lemma lemma_super_sequence_reduction_inequality (p m : ℕ) (A : ℕ → ℤ) (c : ℕ → ℤ)
    (hp : p.Prime) (hm : m ≥ 2)
    (hA : IsSuperSequence p m A)
    (hc_m : c m = p - 1)
    (h_reduced_ineq : ∑ j ∈ Finset.Icc 1 (m - 1), c j * (A j / p) ≥ ∑ j ∈ Finset.Icc 1 (m - 1), (p - 1) * (A j / p)) :
    ∑ j ∈ Finset.Icc 1 m, c j * A j ≥ ∑ j ∈ Finset.Icc 1 m, (p - 1) * A j := by
      -- For $1 \le j \le m-1$, we have $v_p(A_j) = m-j \ge 1$, so $p \mid A_j$. By the factorization theorem $A_j = p \cdot (A_j/p)$.
      have h_div : ∀ j, 1 ≤ j → j < m → (p : ℤ) ∣ A j := by
        intros j hj1 hj2
        have h_val : padicValNat p (A j).toNat = m - j := by
          exact hA.1 j ( Finset.mem_Icc.mpr ⟨ hj1, by linarith ⟩ ) ▸ rfl
        generalize_proofs at *; (
        have h_div : p ∣ Int.toNat (A j) := by
          contrapose! h_val; simp_all +decide [ padicValNat.eq_zero_of_not_dvd ] ; omega;
        generalize_proofs at *; (
        simpa [ ← Int.natCast_dvd_natCast, Int.toNat_of_nonneg ( show 0 ≤ A j from by linarith [ hA.2.2 j ( Finset.mem_Icc.mpr ⟨ hj1, by linarith ⟩ ) ] ) ] using h_div));
      -- Using the factorization theorem $A_j = p \cdot (A_j/p)$, simplify both sum expressions.
      have h_simplified_sums : ∑ j ∈ Finset.Icc 1 (m - 1), c j * A j = (p : ℤ) * ∑ j ∈ Finset.Icc 1 (m - 1), c j * (A j / p) ∧
                             ∑ j ∈ Finset.Icc 1 (m - 1), (p - 1) * A j = (p : ℤ) * ∑ j ∈ Finset.Icc 1 (m - 1), (p - 1) * (A j / p) := by
                               constructor <;> rw [ Finset.mul_sum _ _ _ ] <;> refine' Finset.sum_congr rfl fun x hx => _ <;> obtain ⟨ k, hk ⟩ := h_div x ( Finset.mem_Icc.mp hx |>.1 ) ( Finset.mem_Icc.mp hx |>.2.trans_lt ( Nat.pred_lt ( ne_bot_of_gt hm ) ) ) <;> simp +decide [ hk, mul_left_comm, mul_div_cancel_left₀, hp.ne_zero ] ;
      rcases m with ( _ | _ | m ) <;> simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ];
      exact mul_le_mul_of_nonneg_left h_reduced_ineq <| Nat.cast_nonneg _

/-
If A is a SuperSequence, then any linear combination congruent to the target sum is greater than or equal to the target sum.
-/
lemma lemma_super_sequence_induction (p m : ℕ) (A : ℕ → ℤ) (c : ℕ → ℤ)
    (hp : p.Prime) (hm : m ≥ 1)
    (hA : IsSuperSequence p m A)
    (hc_nonneg : ∀ j, 0 ≤ c j)
    (h_cong : ∑ j ∈ Finset.Icc 1 m, c j * A j ≡ ∑ j ∈ Finset.Icc 1 m, (p - 1) * A j [ZMOD p ^ m]) :
    ∑ j ∈ Finset.Icc 1 m, c j * A j ≥ ∑ j ∈ Finset.Icc 1 m, (p - 1) * A j := by
      induction' m using Nat.strong_induction_on with m ih generalizing A c;
      by_cases hm2 : m ≥ 2;
      · -- By `lemma_abstract_coeff_congruence`, $c_m \equiv p-1 \pmod p$.
        have hc_m_cong : c m ≡ p - 1 [ZMOD p] := by
          convert lemma_abstract_coeff_congruence p m A c hp hm hA h_cong using 1;
        -- If $c_m \ge 2p-1$, then by `lemma_abstract_large_coeff_bound`, the LHS is strictly greater than the RHS.
        by_cases hc_m_ge : c m ≥ 2 * p - 1;
        · exact le_of_lt ( lemma_abstract_large_coeff_bound p m A c hp hm hA hc_nonneg hc_m_ge );
        · -- If $c_m < 2p-1$, since $c_m \ge 0$ and $c_m \equiv p-1 \pmod p$, we must have $c_m = p-1$.
          have hc_m_eq : c m = p - 1 := by
            obtain ⟨ k, hk ⟩ := hc_m_cong.symm.dvd;
            nlinarith [ show k = 0 by nlinarith [ hc_nonneg m, hp.two_le ] ];
          -- By `lemma_super_sequence_reduction_inequality`, we can reduce the problem to showing $\sum_{j=1}^{m-1} c_j (A_j/p) \ge \sum_{j=1}^{m-1} (p-1) (A_j/p)$.
          have h_reduced_ineq : ∑ j ∈ Finset.Icc 1 (m - 1), c j * (A j / p) ≥ ∑ j ∈ Finset.Icc 1 (m - 1), (p - 1) * (A j / p) := by
            apply ih (m - 1) (Nat.sub_lt hm zero_lt_one) (fun j => A j / p) (fun j => c j);
            · exact Nat.sub_pos_of_lt hm2;
            · convert lemma_super_sequence_step p m A hp hm2 hA using 1;
            · assumption;
            · convert lemma_reduction_step p m A c hp ( by linarith ) ( fun j hj => hA.1 j hj ) hc_m_eq h_cong using 1;
          convert lemma_super_sequence_reduction_inequality p m A c hp hm2 hA hc_m_eq h_reduced_ineq using 1;
      · interval_cases m ; norm_num at *;
        have := lemma_super_sequence_base p A c hp hA hc_nonneg h_cong; aesop;

/-
The sequence of binomial coefficients binom(n, p^j) is a SuperSequence.
-/
lemma lemma_binom_is_super_sequence (n p : ℕ)
    (hp : p ∈ n.factorization.support)
    (h_not_prime_pow : ∀ q k, Nat.Prime q → n ≠ q ^ k) :
    IsSuperSequence p (n.factorization p) (fun j => (Nat.choose n (p ^ j) : ℤ)) := by
      simp +zetaDelta at *;
      refine' ⟨ _, _, _ ⟩;
      · -- Apply the lemma1_equality to each j in the range 1 to the factorization of n at p.
        intros j hj
        have h_val : padicValNat p (Nat.choose n (p ^ j)) = n.factorization p - j := by
          have h_val : padicValNat p n ≥ j := by
            rw [ ← Nat.factorization_def ] ; aesop;
            exact hp.1;
          convert lemma1_equality n j p hp.1 ( Finset.mem_Icc.mp hj |>.1 ) h_val using 1;
          rw [ Nat.factorization_def ] ; aesop;
        exact h_val;
      · convert lemma_super_increasing n p using 1;
        aesop;
      · exact fun j hj => Nat.cast_pos.mpr ( Nat.choose_pos ( show p ^ j ≤ n from Nat.le_of_dvd ( Nat.pos_of_ne_zero hp.2.2 ) ( Nat.dvd_trans ( pow_dvd_pow _ ( Finset.mem_Icc.mp hj |>.2 ) ) ( Nat.ordProj_dvd _ _ ) ) ) )

/-
If x and y are coprime and at least 2, and n is large enough and not a prime power, then binom(n, xy) >= x binom(n, x) + y binom(n, y).
-/
lemma lemma_decomposition_step (n x y : ℕ)
    (hx : x ≥ 2) (hy : y ≥ 2)
    (hn : n ≥ 2 * x * y)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) :
    (Nat.choose n (x * y) : ℤ) ≥ x * (Nat.choose n x : ℤ) + y * (Nat.choose n y : ℤ) := by
      by_cases hxy : y ≥ x;
      · exact_mod_cast lemma2 n x y hx hxy hn h_not_prime_pow;
      · have := lemma2 n y x ( by linarith ) ( by linarith ) ( by linarith ) ( fun p k hp => h_not_prime_pow p k hp ) ; ring_nf at *; linarith;

/-
DecompositionSum is additive for coprime inputs.
-/
noncomputable def DecompositionSum (n m : ℕ) : ℤ :=
  ∑ p ∈ m.factorization.support, (p ^ m.factorization p : ℤ) * (Nat.choose n (p ^ m.factorization p) : ℤ)

lemma lemma_decomposition_sum_additivity (n x y : ℕ)
    (h_coprime : Nat.Coprime x y) :
    DecompositionSum n (x * y) = DecompositionSum n x + DecompositionSum n y := by
      unfold DecompositionSum;
      by_cases hx : x = 0 <;> by_cases hy : y = 0 <;> simp_all +decide [ Nat.factorization_mul ];
      rw [ Finsupp.support_add_eq ];
      · rw [ Finset.sum_union ];
        · congr! 1;
          · refine' Finset.sum_congr rfl fun p hp => _;
            rw [ Nat.factorization_eq_zero_of_not_dvd ( fun h => Nat.Prime.not_dvd_one ( Nat.prime_of_mem_primeFactors hp ) <| h_coprime.gcd_eq_one ▸ Nat.dvd_gcd ( Nat.dvd_of_mem_primeFactors hp ) h ) ] ; aesop;
          · refine' Finset.sum_congr rfl fun p hp => _;
            rw [ Nat.factorization_eq_zero_of_not_dvd ( fun h => by have := Nat.dvd_gcd h ( Nat.dvd_of_mem_primeFactors hp ) ; aesop ) ] ; aesop;
        · exact h_coprime.disjoint_primeFactors;
      · exact h_coprime.disjoint_primeFactors

/-
If x is a prime power, DecompositionSum n x equals x * binom(n, x).
-/
lemma lemma_decomposition_sum_prime_pow (n x : ℕ)
    (hx : IsPrimePow x) :
    DecompositionSum n x = x * (Nat.choose n x : ℤ) := by
      obtain ⟨ p, k, hp, hk, rfl ⟩ := hx;
      unfold DecompositionSum;
      simp +decide [ hp.nat_prime, Nat.factorization_pow ];
      rw [ Finsupp.support_single_ne_zero ] <;> aesop

/-
If the inductive hypothesis holds, then m * binom(n, m) >= DecompositionSum n m.
-/
lemma lemma_term_bound (n m : ℕ)
    (hm : m ≥ 2)
    (h_ind : ¬ IsPrimePow m → (Nat.choose n m : ℤ) ≥ DecompositionSum n m) :
    (m : ℤ) * (Nat.choose n m : ℤ) ≥ DecompositionSum n m := by
      by_cases h_prime_pow : IsPrimePow m;
      · have h_dec : DecompositionSum n m = m * (Nat.choose n m : ℤ) := by
          convert lemma_decomposition_sum_prime_pow n m h_prime_pow;
        rw [h_dec];
      · exact le_trans ( h_ind h_prime_pow ) ( le_mul_of_one_le_left ( Nat.cast_nonneg _ ) ( by norm_cast; linarith ) )

/-
Inductive step for decomposition inequality: if it holds for coprime factors, it holds for the product.
-/
lemma lemma_decomposition_inequality_step_v2 (n x y : ℕ)
    (hx : x ≥ 2) (hy : y ≥ 2)
    (h_coprime : Nat.Coprime x y)
    (hn : n ≥ 2 * x * y)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (hx_ind : ¬ IsPrimePow x → (Nat.choose n x : ℤ) ≥ DecompositionSum n x)
    (hy_ind : ¬ IsPrimePow y → (Nat.choose n y : ℤ) ≥ DecompositionSum n y) :
    (Nat.choose n (x * y) : ℤ) ≥ DecompositionSum n (x * y) := by
      -- By `lemma_decomposition_step`, we have $\binom{n}{xy} \ge x \binom{n}{x} + y \binom{n}{y}$.
      have h_decomp : (Nat.choose n (x * y) : ℤ) ≥ x * (Nat.choose n x : ℤ) + y * (Nat.choose n y : ℤ) := by
        convert lemma_decomposition_step n x y hx hy hn h_not_prime_pow using 1;
      -- By `lemma_decomposition_sum_additivity`, we have `DecompositionSum n (x * y) = DecompositionSum n x + DecompositionSum n y`.
      have h_additivity : DecompositionSum n (x * y) = DecompositionSum n x + DecompositionSum n y := by
        apply lemma_decomposition_sum_additivity; assumption;
      -- By `lemma_term_bound`, we have `x * binom(n, x) ≥ DecompositionSum n x` and `y * binom(n, y) ≥ DecompositionSum n y`.
      have h_term_bound_x : (x : ℤ) * (Nat.choose n x : ℤ) ≥ DecompositionSum n x := by
        apply lemma_term_bound n x hx hx_ind;
      have h_term_bound_y : (y : ℤ) * (Nat.choose n y : ℤ) ≥ DecompositionSum n y := by
        apply lemma_term_bound n y hy hy_ind;
      linarith [h_decomp, h_additivity, h_term_bound_x, h_term_bound_y];

/-
For any m which is not a prime power and 2m <= n, binom(n, m) >= DecompositionSum n m.
-/
lemma lemma_decomposition_inequality (n m : ℕ)
    (hm : 1 ≤ m) (hm_lt : m < n)
    (hn : 2 * m ≤ n)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (h_m_not_prime_pow : ¬ IsPrimePow m) :
    (Nat.choose n m : ℤ) ≥ DecompositionSum n m := by
      by_contra h_contra;
      -- By strong induction on $m$, we can assume the inequality holds for all $m' < m$.
      have h_ind : ∀ m' < m, ¬IsPrimePow m' → (Nat.choose n m' : ℤ) ≥ DecompositionSum n m' := by
        intros m' hm' hm'_not_prime_pow
        induction' m' using Nat.strong_induction_on with m' ih;
        by_cases hm'_gt_one : m' > 1;
        · -- Since $m'$ is not a prime power, we can write $m' = x y$ where $x, y \ge 2$ are coprime.
          obtain ⟨x, y, hx, hy, h_coprime, h_prod⟩ : ∃ x y : ℕ, x ≥ 2 ∧ y ≥ 2 ∧ Nat.Coprime x y ∧ m' = x * y := by
            -- Since $m'$ is not a prime power, it must have at least two distinct prime factors.
            obtain ⟨p, hp⟩ : ∃ p : ℕ, Nat.Prime p ∧ p ∣ m' ∧ ¬(p ^ (Nat.factorization m' p) = m') := by
              by_cases h_prime_pow : ∀ p : ℕ, Nat.Prime p → p ∣ m' → p ^ (Nat.factorization m' p) = m';
              · obtain ⟨p, hp⟩ : ∃ p : ℕ, Nat.Prime p ∧ p ∣ m' := by
                  exact Nat.exists_prime_and_dvd hm'_gt_one.ne';
                exact False.elim <| hm'_not_prime_pow <| h_prime_pow p hp.1 hp.2 ▸ hp.1.isPrimePow.pow ( Nat.ne_of_gt <| Nat.pos_of_ne_zero <| Finsupp.mem_support_iff.mp <| by aesop );
              · exact by push_neg at h_prime_pow; exact h_prime_pow;
            refine' ⟨ p ^ ( Nat.factorization m' p ), m' / p ^ ( Nat.factorization m' p ), _, _, _, _ ⟩;
            · exact one_lt_pow₀ hp.1.one_lt ( Nat.ne_of_gt ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by aesop ) ) ) ) |> Nat.lt_of_lt_of_le <| Nat.le_refl _;
            · exact Nat.lt_of_le_of_ne ( Nat.div_pos ( Nat.le_of_dvd hm'_gt_one.le ( Nat.ordProj_dvd _ _ ) ) ( pow_pos hp.1.pos _ ) ) ( Ne.symm <| by intro t; have := Nat.div_mul_cancel ( Nat.ordProj_dvd m' p ) ; aesop );
            · exact Nat.Coprime.pow_left _ ( hp.1.coprime_iff_not_dvd.mpr <| Nat.not_dvd_ordCompl ( by aesop ) <| by aesop );
            · rw [ Nat.mul_div_cancel' ( Nat.ordProj_dvd _ _ ) ];
          have h_ind_x : ¬IsPrimePow x → (Nat.choose n x : ℤ) ≥ DecompositionSum n x := by
            exact ih x ( by nlinarith ) ( by nlinarith )
          have h_ind_y : ¬IsPrimePow y → (Nat.choose n y : ℤ) ≥ DecompositionSum n y := by
            exact ih y ( by nlinarith ) ( by nlinarith )
          have h_ind_step : (Nat.choose n (x * y) : ℤ) ≥ DecompositionSum n (x * y) := by
            apply lemma_decomposition_inequality_step_v2 n x y hx hy h_coprime (by
            nlinarith only [ hm', hm_lt, hn, h_prod ]) (by
            exact h_not_prime_pow) (by
            exact h_ind_x) (by
            exact h_ind_y)
          aesop;
        · interval_cases m' <;> simp_all +decide [ DecompositionSum ];
      -- Since $m$ is not a prime power, we can write $m = x y$ where $x, y \ge 2$ are coprime.
      obtain ⟨x, y, hx, hy, h_coprime, h_prod⟩ : ∃ x y : ℕ, 2 ≤ x ∧ 2 ≤ y ∧ Nat.Coprime x y ∧ m = x * y := by
        -- Since $m$ is not a prime power, there exists a prime $p$ such that $p^a \mid m$ but $p^{a+1} \nmid m$.
        obtain ⟨p, a, hp, ha⟩ : ∃ p a : ℕ, Nat.Prime p ∧ a > 0 ∧ p^a ∣ m ∧ ¬p^(a+1) ∣ m := by
          obtain ⟨p, hp_prime, hp_div⟩ : ∃ p : ℕ, Nat.Prime p ∧ p ∣ m := by
            refine Nat.exists_prime_and_dvd ?_;
            rintro rfl; simp_all +decide [ DecompositionSum ] ;
          exact ⟨ p, Nat.factorization m p, hp_prime, Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by aesop ) ), Nat.ordProj_dvd _ _, Nat.pow_succ_factorization_not_dvd ( by aesop ) ( by aesop ) ⟩;
        obtain ⟨x, y, hx, hy, h_coprime, h_prod⟩ : ∃ x y : ℕ, x = p^a ∧ y = m / p^a ∧ Nat.Coprime x y ∧ m = x * y := by
          exact ⟨ _, _, rfl, rfl, Nat.Coprime.pow_left _ <| hp.coprime_iff_not_dvd.mpr fun h => ha.2.2 <| by convert Nat.mul_dvd_mul_left ( p ^ a ) h using 1; rw [ Nat.mul_div_cancel' ha.2.1 ], by rw [ Nat.mul_div_cancel' ha.2.1 ] ⟩;
        refine' ⟨ x, y, _, _, h_coprime, h_prod ⟩ <;> subst_vars <;> norm_num at *;
        · exact one_lt_pow₀ hp.one_lt ha.1.ne';
        · rcases y with ( _ | _ | y ) <;> norm_num at *;
          exact h_m_not_prime_pow <| hp.isPrimePow.pow <| by linarith;
      -- Apply the decomposition inequality step with $x$ and $y$.
      have h_step : (Nat.choose n (x * y) : ℤ) ≥ DecompositionSum n (x * y) := by
        apply lemma_decomposition_inequality_step_v2 n x y hx hy h_coprime (by
        grind) h_not_prime_pow (by
        exact fun hx' => h_ind x ( by nlinarith ) hx' |> fun h => by aesop;) (by
        exact fun h => h_ind y ( by nlinarith ) h |> fun h' => by simpa [ h_prod ] using h';);
      aesop

/-
S_max is defined as K(n). target(n) is S_max(n) - n.
-/
noncomputable def S_max (n : ℕ) : ℤ := K n

lemma lemma_target_eq_S_max_sub_n (n : ℕ) : target n = S_max n - n := by
  unfold S_max; norm_num [ target ] ; ring_nf;
  unfold K; norm_num [ Finset.sum_add_distrib, mul_comm ] ;
  rw [ ← Finset.sum_neg_distrib, ← Finset.sum_add_distrib ] ; exact Finset.sum_congr rfl fun p hp => by rw [ Nat.cast_sub ( Nat.pos_of_mem_primeFactors hp ) ] ; ring;

/-
S_max can be written as a double sum where the term is (p-1) * binom(n, p^j).
-/
lemma lemma_S_max_def (n : ℕ) :
    S_max n = ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), (p - 1) * (Nat.choose n (p ^ j) : ℤ) := by
      unfold S_max;
      unfold K;
      simp +decide [ mul_comm, Finset.mul_sum _ _ _ ];
      exact Finset.sum_congr rfl fun p hp => Finset.sum_congr rfl fun q hq => by rw [ Nat.cast_pred ( Nat.pos_of_mem_primeFactors hp ) ] ;

/-
For any prime power factor p^j of n (where n is not a prime power), the binomial coefficient binom(n, p^j) is at least n.
-/
lemma lemma_binom_ge_n (n p j : ℕ)
    (hp : p ∈ n.factorization.support)
    (hj_le : j ≤ n.factorization p)
    (h_not_prime_pow : ∀ q k, Nat.Prime q → n ≠ q ^ k) :
    (Nat.choose n (p ^ j) : ℤ) ≥ n := by
      -- Since $p$ is a prime factor of $n$, we have $1 \leq p^j < n$.
      have h_bounds : 1 ≤ p ^ j ∧ p ^ j < n := by
        exact ⟨ Nat.one_le_pow _ _ ( Nat.pos_of_mem_primeFactors hp ), lt_of_le_of_ne ( Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop ) ) ( Nat.dvd_trans ( pow_dvd_pow _ hj_le ) ( Nat.ordProj_dvd _ _ ) ) ) ( by specialize h_not_prime_pow p ( n.factorization p ) ( Nat.prime_of_mem_primeFactors hp ) ; aesop ) ⟩;
      have h_binom_ge_n : ∀ k, 1 ≤ k → k < n → (Nat.choose n k : ℤ) ≥ n := by
        intros k hk1 hk2
        by_cases hk3 : k = 1 ∨ k = n - 1;
        · cases n <;> aesop;
        · have h_binom_ge_n : k * (n.choose k : ℤ) ≥ n * (n - 1).choose (k - 1) := by
            norm_cast ; rcases k <;> simp_all +decide
            cases n <;> simp_all +decide [ Nat.succ_mul_choose_eq ];
            linarith;
          rcases n with ( _ | _ | n ) <;> rcases k with ( _ | _ | k ) <;> norm_num [ Nat.succ_mul_choose_eq ] at *;
          nlinarith [ show ( Nat.choose ( n + 1 ) ( k + 1 ) : ℤ ) ≥ k + 2 from mod_cast Nat.le_induction ( by simp +arith +decide ) ( fun m hm ih ↦ by { rw [ Nat.choose_succ_succ ] ; linarith } ) _ ( show k + 1 ≤ n from by linarith ) ] ;
      exact h_binom_ge_n _ h_bounds.1 h_bounds.2

/-
For any integer a not divisible by prime p, and any integer x, there exists a coefficient c in [0, p-1] such that c * a is congruent to x modulo p.
-/
lemma lemma_solve_mod_p (a x : ℤ) (p : ℕ) (hp : p.Prime) (ha : ¬ (p : ℤ) ∣ a) :
    ∃ c : ℤ, 0 ≤ c ∧ c ≤ p - 1 ∧ c * a ≡ x [ZMOD p] := by
      have h_inv : ∃ b : ℤ, a * b ≡ 1 [ZMOD p] := by
        have := Int.gcd_eq_gcd_ab a p;
        exact ⟨ Int.gcdA a p, Int.modEq_iff_dvd.mpr ⟨ Int.gcdB a p, by linarith [ show Int.gcd a p = 1 from Nat.coprime_comm.mp <| hp.coprime_iff_not_dvd.mpr fun h => ha <| Int.natCast_dvd.mpr h ] ⟩ ⟩;
      obtain ⟨ b, hb ⟩ := h_inv; use ( x * b ) % p; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff, mul_comm ] ;
      exact ⟨ Int.emod_nonneg _ ( Int.natCast_ne_zero.mpr hp.ne_zero ), Int.le_sub_one_of_lt ( Int.emod_lt_of_pos _ ( Int.natCast_pos.mpr hp.pos ) ), by linear_combination' hb * x ⟩

/-
Inductive step for representing integers using a SuperSequence.
-/
lemma lemma_super_sequence_representation_induction_step (p m : ℕ) (A : ℕ → ℤ)
    (hp : p.Prime) (hm : m ≥ 2)
    (hA : IsSuperSequence p m A)
    (h_ind : ∀ y : ℤ, ∃ c' : ℕ → ℤ, (∀ j ∈ Finset.Icc 1 (m - 1), 0 ≤ c' j ∧ c' j ≤ p - 1) ∧
             y ≡ ∑ j ∈ Finset.Icc 1 (m - 1), c' j * (A j / p) [ZMOD p ^ (m - 1)]) :
    ∀ x : ℤ, ∃ c : ℕ → ℤ, (∀ j ∈ Finset.Icc 1 m, 0 ≤ c j ∧ c j ≤ p - 1) ∧
             x ≡ ∑ j ∈ Finset.Icc 1 m, c j * A j [ZMOD p ^ m] := by
               -- By the lemma_solve_mod_p, there exists a coefficient $c_m \in [0, p-1]$ such that $c_m A_m \equiv x \pmod{p}$.
               have h_coeff_m : ∀ x : ℤ, ∃ c_m : ℤ, 0 ≤ c_m ∧ c_m ≤ p - 1 ∧ c_m * A m ≡ x [ZMOD p] := by
                 intro x
                 have h_not_div : ¬ (p : ℤ) ∣ A m := by
                   have := hA.1 m ( Finset.mem_Icc.mpr ⟨ by linarith, by linarith ⟩ ) ; simp_all +decide [ ← Int.natCast_dvd_natCast ] ;
                   cases max_cases ( A m ) 0 <;> simp_all +decide
                   · exact this.resolve_left hp.ne_one |> Or.rec ( fun h => by linarith [ hA.2.2 m ( Finset.mem_Icc.mpr ⟨ by linarith, by linarith ⟩ ) ] ) fun h => h;
                   · linarith [ hA.2.2 m ( Finset.mem_Icc.mpr ⟨ by linarith, by linarith ⟩ ) ]
                 generalize_proofs at *; (
                 haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, Int.modEq_iff_dvd ] ;
                 -- Since $A_m$ is not divisible by $p$, we can find $c_m$ such that $c_m \cdot A_m \equiv x \pmod{p}$.
                 obtain ⟨c_m, hc_m⟩ : ∃ c_m : ZMod p, c_m * (A m : ZMod p) = x := by
                   exact ⟨ x / A m, by rw [ div_mul_cancel₀ _ h_not_div ] ⟩;
                 exact ⟨ c_m.val, by linarith [ c_m.val_lt ], by linarith [ c_m.val_lt ], by simpa [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] using sub_eq_zero.mpr hc_m.symm ⟩)
               generalize_proofs at *; (
               intro x
               obtain ⟨c_m, hc_m⟩ := h_coeff_m x
               set y := (x - c_m * A m) / p
               obtain ⟨c', hc'⟩ := h_ind y
               use fun j => if j = m then c_m else if j ∈ Finset.Icc 1 (m - 1) then c' j else 0
               generalize_proofs at *; (
               -- By combining the results from the induction hypothesis and the definition of y, we can conclude the proof.
               have h_combined : x ≡ c_m * A m + p * (∑ j ∈ Finset.Icc 1 (m - 1), c' j * (A j / p)) [ZMOD p ^ m] := by
                 have h_combined : x - c_m * A m ≡ p * (∑ j ∈ Finset.Icc 1 (m - 1), c' j * (A j / p)) [ZMOD p ^ m] := by
                   rw [ Int.modEq_iff_dvd ] at *;
                   convert mul_dvd_mul_left ( p : ℤ ) hc'.2 using 1 ; ring_nf;
                   · rw [ ← pow_succ', Nat.sub_add_cancel ( by linarith ) ];
                   · rw [ mul_sub, Int.mul_ediv_cancel' hc_m.2.2 ]
                 generalize_proofs at *; (
                 simpa using h_combined.add_left ( c_m * A m ) |> Int.ModEq.trans <| by ring_nf; norm_num;)
               generalize_proofs at *; (
               refine' ⟨ _, _ ⟩
               generalize_proofs at *; (
               grind);
               convert h_combined using 1 ; simp +decide [ Finset.sum_ite, Finset.filter_ne', Finset.filter_eq', Finset.mul_sum _ _ _, mul_left_comm, ] ; ring_nf;
               rw [ if_pos ( by linarith ) ] ; simp +decide [ mul_comm, mul_left_comm ] ;
               refine' Finset.sum_bij ( fun x hx => x ) _ _ _ _ <;> simp +decide
               · exact fun b hb₁ hb₂ => ⟨ ⟨ hb₁, lt_of_le_of_lt hb₂ ( Nat.pred_lt ( ne_bot_of_gt hm ) ) ⟩, hb₁, hb₂ ⟩;
               · intro a ha₁ ha₂ ha₃ ha₄; rw [ Int.mul_ediv_cancel' ] ; ring; exact ( by have := hA.1 a ( Finset.mem_Icc.mpr ⟨ by linarith, by linarith ⟩ ) ; exact ( by
                   have h_div : p ^ (m - a) ∣ Int.toNat (A a) := by
                     rw [ ← this ] ; exact pow_padicValNat_dvd;
                   generalize_proofs at *; (
                   rw [ ← Int.natCast_dvd_natCast ] at *; simp_all +decide [ Int.toNat_of_nonneg ( show 0 ≤ A a from hA.2.2 a ( Finset.mem_Icc.mpr ⟨ by linarith, by linarith ⟩ ) |> le_of_lt ) ] ;
                   exact dvd_trans ( dvd_pow_self _ ( Nat.sub_ne_zero_of_lt ha₂ ) ) h_div) ) ) ;)))

/-
For any SuperSequence A of length m and any integer x, there exist coefficients c_j in [0, p-1] such that the linear combination matches x modulo p^m.
-/
lemma lemma_super_sequence_representation (p m : ℕ) (A : ℕ → ℤ) (x : ℤ)
    (hp : p.Prime) (hm : m ≥ 1)
    (hA : IsSuperSequence p m A) :
    ∃ c : ℕ → ℤ,
      (∀ j ∈ Finset.Icc 1 m, 0 ≤ c j ∧ c j ≤ p - 1) ∧
      x ≡ ∑ j ∈ Finset.Icc 1 m, c j * A j [ZMOD p ^ m] := by
        induction' hm with m hm ih generalizing A x;
        · -- For the base case when $m = 1$, we can directly apply the lemma_solve_mod_p.
          obtain ⟨c, hc⟩ : ∃ c : ℤ, 0 ≤ c ∧ c ≤ p - 1 ∧ c * A 1 ≡ x [ZMOD p] := by
            -- Since $p$ is prime and $A 1$ is not divisible by $p$, we can apply Lemma 3.
            have h_not_div : ¬ (p : ℤ) ∣ A 1 := by
              have := hA.1 1 ( by norm_num );
              by_cases h : ( A 1 |> Int.toNat ) = 0 <;> simp_all +decide [ padicValNat.eq_zero_iff ];
              · exact absurd h ( not_le_of_gt ( hA.2.2 1 ( by norm_num ) ) );
              · exact fun h' => this.resolve_left hp.ne_one <| by simpa [ ← Int.natCast_dvd_natCast, Int.toNat_of_nonneg h.le ] using h';
            exact lemma_solve_mod_p (A 1) x p hp h_not_div;
          exact ⟨ fun _ => c, fun j hj => ⟨ hc.1, hc.2.1 ⟩, by simpa using hc.2.2.symm ⟩;
        · -- Apply the induction hypothesis to the sequence A/p of length m.
          have h_ind_step : ∀ y : ℤ, ∃ c' : ℕ → ℤ, (∀ j ∈ Finset.Icc 1 m, 0 ≤ c' j ∧ c' j ≤ p - 1) ∧ y ≡ ∑ j ∈ Finset.Icc 1 m, c' j * (A j / p) [ZMOD p ^ m] := by
            intros y
            apply ih (fun j => A j / p) y;
            apply lemma_super_sequence_step p (Nat.succ m) A hp (by linarith [Nat.succ_le_iff.mp hm]) hA;
          exact lemma_super_sequence_representation_induction_step p m.succ A hp ( Nat.succ_le_succ hm ) hA ( h_ind_step ) x

/-
Cross terms vanish modulo prime powers.
-/
lemma lemma_cross_term_vanishes (n : ℕ) (p q : ℕ) (j : ℕ)
    (hp : p ∈ n.factorization.support)
    (hq : q ∈ n.factorization.support)
    (hpq : p ≠ q)
    (hj_le : j ≤ n.factorization q) :
    (Nat.choose n (q ^ j) : ℤ) ≡ 0 [ZMOD p ^ (n.factorization p)] := by
      -- By lemma_kummer_theorem, since p ≠ q, we have padicValNat p (Nat.choose n (q^j)) ≥ padicValNat p n.
      have h_p_val : padicValNat p (Nat.choose n (q ^ j)) ≥ padicValNat p n := by
        -- By Lemma Kummer, the p-adic valuation of $\binom{n}{q^j}$ is at least the p-adic valuation of $n$.
        have h_kummer : padicValNat p (Nat.choose n (q ^ j) * q ^ j) ≥ padicValNat p n := by
          have h_kummer : padicValNat p (Nat.choose n (q ^ j) * q ^ j) = padicValNat p (n * Nat.choose (n - 1) (q ^ j - 1)) := by
            rw [ ← Nat.succ_pred_eq_of_pos ( Nat.one_le_pow j q ( Nat.pos_of_mem_primeFactors hq ) ) ];
            cases n <;> cases q <;> simp_all +decide [ Nat.succ_mul_choose_eq ];
          have h_kummer : padicValNat p (n * Nat.choose (n - 1) (q ^ j - 1)) = padicValNat p n + padicValNat p (Nat.choose (n - 1) (q ^ j - 1)) := by
            convert padicValNat.mul _ _ using 1;
            · exact ⟨ Nat.prime_of_mem_primeFactors hp ⟩;
            · aesop_cat;
            · exact Nat.ne_of_gt <| Nat.choose_pos <| Nat.sub_le_sub_right ( show q ^ j ≤ n from Nat.le_of_dvd ( Nat.pos_of_ne_zero <| by aesop ) <| Nat.dvd_trans ( pow_dvd_pow _ hj_le ) <| Nat.ordProj_dvd _ _ ) _;
          linarith [ Nat.zero_le ( padicValNat p ( Nat.choose ( n - 1 ) ( q ^ j - 1 ) ) ) ];
        by_cases h : Nat.choose n ( q ^ j ) = 0 <;> by_cases h' : q ^ j = 0 <;> simp_all +decide [ padicValNat.mul ];
        haveI := Fact.mk hp.1; rw [ padicValNat.eq_zero_of_not_dvd ( show ¬ p ∣ q ^ j from mt ( hp.1.dvd_of_dvd_pow ) ( by rw [ Nat.dvd_prime hq.1 ] ; aesop ) ) ] at *; aesop;
      -- Since $p^v divides $\binom{n}{q^j}$, we have $\binom{n}{q^j} \equiv 0 \pmod{p^v}$.
      have h_div : p ^ (padicValNat p n) ∣ Nat.choose n (q ^ j) := by
        have h_congr_zero : p ^ (Nat.factorization (Nat.choose n (q ^ j)) p) ∣ Nat.choose n (q ^ j) := by
          exact Nat.ordProj_dvd _ _;
        convert Nat.dvd_trans ( pow_dvd_pow _ _ ) h_congr_zero;
        rw [ Nat.factorization_def ] ; aesop;
        exact Nat.prime_of_mem_primeFactors hp;
      convert Int.modEq_zero_iff_dvd.mpr ( Int.natCast_dvd_natCast.mpr h_div ) using 1;
      norm_num [ Nat.factorization ] at * ; aesop ( simp_config := { singlePass := true } ) ;

/-
The total sum of canonical terms is congruent to the local sum for p modulo p^(v_p(n)).
-/
lemma lemma_total_sum_congruence (n : ℕ) (c : ℕ → ℕ → ℤ) (p : ℕ) (hp : p ∈ n.factorization.support) :
    (∑ q ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization q), c q j * (Nat.choose n (q ^ j) : ℤ)) ≡
    (∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)) [ZMOD p ^ (n.factorization p)] := by
      -- By Lemma~\ref{lem:cross_term_vanishes}, the binomial terms vanish modulo $p^{e_p}$.
      have h_cross_term_vanishes : ∀ q ∈ n.factorization.support, q ≠ p → ∀ j ∈ Finset.Icc 1 (n.factorization q), (Nat.choose n (q ^ j) : ℤ) ≡ 0 [ZMOD p ^ (n.factorization p)] := by
        norm_num +zetaDelta at *;
        intros q hq hq' hn hqp j hj hj'; exact (by
        have := @lemma_cross_term_vanishes n p q j; aesop;);
      generalize_proofs at *; (
      simp_all +decide
      have h_split_sum : ∑ q ∈ n.primeFactors \ {p}, ∑ j ∈ Finset.Icc 1 (n.factorization q), c q j * (Nat.choose n (q ^ j) : ℤ) ≡ 0 [ZMOD p ^ (n.factorization p)] := by
        exact Int.modEq_zero_iff_dvd.mpr <| Finset.dvd_sum fun q hq => Finset.dvd_sum fun j hj => dvd_mul_of_dvd_right ( Int.dvd_of_emod_eq_zero <| h_cross_term_vanishes q ( Nat.prime_of_mem_primeFactors <| Finset.mem_sdiff.mp hq |>.1 ) ( Nat.dvd_of_mem_primeFactors <| Finset.mem_sdiff.mp hq |>.1 ) ( by aesop ) j ( Finset.mem_Icc.mp hj |>.1 ) ( Finset.mem_Icc.mp hj |>.2 ) ) _;
      generalize_proofs at *; (
      convert h_split_sum.add_left ( ∑ j ∈ Finset.Icc 1 ( n.factorization p ), c p j * ( n.choose ( p ^ j ) : ℤ ) ) using 1 ; rw [ Finset.sum_eq_add_sum_diff_singleton ( show p ∈ n.primeFactors from by aesop ) ] ; ring;))

/-
If A is congruent to x modulo each prime power factor of n (where n is non-zero), then A is congruent to x modulo n.
-/
lemma lemma_crt_implication (n : ℕ) (A x : ℤ)
    (hn : n ≠ 0)
    (h_cong : ∀ p ∈ n.factorization.support, A ≡ x [ZMOD p ^ (n.factorization p)]) :
    A ≡ x [ZMOD n] := by
      -- Since $n \ne 0$, $n = \prod_{p} p^{v_p(n)}$. The moduli $m_p = p^{v_p(n)}$ are pairwise coprime for distinct primes $p$.
      have h_coprime : ∀ p q : ℕ, p ∈ n.factorization.support → q ∈ n.factorization.support → p ≠ q → Nat.gcd (p ^ (n.factorization p)) (q ^ (n.factorization q)) = 1 := by
        exact fun p q hp hq hpq => Nat.coprime_pow_primes _ _ ( by aesop ) ( by aesop ) hpq;
      -- By the Chinese Remainder Theorem, if $A \equiv x \pmod{m_p}$ for all $p$, then $A \equiv x \pmod{\text{lcm}(m_p)}$.
      have h_crt : A ≡ x [ZMOD ∏ p ∈ n.factorization.support, (p ^ (n.factorization p) : ℤ)] := by
        have h_crt : ∀ {S : Finset ℕ}, (∀ p ∈ S, ∀ q ∈ S, p ≠ q → Nat.gcd (p ^ (n.factorization p)) (q ^ (n.factorization q)) = 1) → (∀ p ∈ S, A ≡ x [ZMOD (p ^ (n.factorization p) : ℤ)]) → A ≡ x [ZMOD (∏ p ∈ S, (p ^ (n.factorization p) : ℤ))] := by
          intros S h_coprime h_cong;
          induction' S using Finset.induction with p S hS ih;
          · norm_num [ Int.modEq_iff_dvd ];
          · rw [ Finset.prod_insert hS ];
            rw [ ← Int.modEq_and_modEq_iff_modEq_mul ];
            · exact ⟨ h_cong p ( Finset.mem_insert_self _ _ ), ih ( fun q hq r hr hqr => h_coprime q ( Finset.mem_insert_of_mem hq ) r ( Finset.mem_insert_of_mem hr ) hqr ) ( fun q hq => h_cong q ( Finset.mem_insert_of_mem hq ) ) ⟩;
            · simp +zetaDelta at *;
              exact_mod_cast Nat.Coprime.prod_right fun q hq => h_coprime.1 q hq ( Ne.symm <| by aesop );
        exact h_crt ( fun p hp q hq hpq => h_coprime p q hp hq hpq ) h_cong;
      convert h_crt using 1;
      exact_mod_cast Eq.symm ( Nat.factorization_prod_pow_eq_self hn )

/-
Existence of canonical representation for any integer x modulo n.
-/
lemma lemma_canonical_representation_exists (n : ℕ) (x : ℤ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) :
    ∃ c : ℕ → ℕ → ℤ,
      (∀ p ∈ n.factorization.support, ∀ j ∈ Finset.Icc 1 (n.factorization p), 0 ≤ c p j ∧ c p j ≤ p - 1) ∧
      x ≡ ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ) [ZMOD n] := by
        have h_exists_c : ∀ p ∈ n.factorization.support, ∃ c_p : ℕ → ℤ,
          (∀ j ∈ Finset.Icc 1 (n.factorization p), 0 ≤ c_p j ∧ c_p j ≤ p - 1) ∧
          x ≡ ∑ j ∈ Finset.Icc 1 (n.factorization p), c_p j * (Nat.choose n (p ^ j) : ℤ) [ZMOD p ^ (n.factorization p)] := by
            intro p hp
            have h_super_sequence : IsSuperSequence p (n.factorization p) (fun j => (Nat.choose n (p ^ j) : ℤ)) := by
              exact lemma_binom_is_super_sequence n p hp h_not_prime_pow
            generalize_proofs at *; (
            convert lemma_super_sequence_representation p ( n.factorization p ) ( fun j => ( n.choose ( p ^ j ) : ℤ ) ) x ( Nat.prime_of_mem_primeFactors hp ) ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp hp ) ) h_super_sequence using 1);
        choose! c hc using h_exists_c;
        refine' ⟨ c, fun p hp j hj => hc p hp |>.1 j hj, _ ⟩;
        convert lemma_crt_implication n x ( ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 ( n.factorization p ), c p j * Nat.choose n ( p ^ j ) ) hn _ using 1;
        intro p hp; specialize hc p hp; simp_all +decide [ Int.ModEq ] ;
        rw [ Finset.sum_eq_add_sum_diff_singleton ( Nat.mem_primeFactors.mpr ⟨ hp.1, hp.2, hn ⟩ ) ];
        simp +decide [ Int.emod_eq_emod_iff_emod_sub_eq_zero ];
        refine' Finset.dvd_sum fun q hq => _;
        refine' Finset.dvd_sum fun j hj => dvd_mul_of_dvd_right _ _;
        have h_cross_term_vanishes : (Nat.choose n (q ^ j) : ℤ) ≡ 0 [ZMOD p ^ (n.factorization p)] := by
          have := lemma_cross_term_vanishes n p q j (by aesop) (by aesop) (by grind) (by linarith [ Finset.mem_Icc.mp hj ])
          exact this
        generalize_proofs at *;
        exact Int.modEq_zero_iff_dvd.mp h_cross_term_vanishes

/-
Existence of canonical representation for any integer x modulo n.
-/
lemma lemma_canonical_representation_exists_v2 (n : ℕ) (x : ℤ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) :
    ∃ c : ℕ → ℕ → ℤ,
      (∀ p ∈ n.factorization.support, ∀ j ∈ Finset.Icc 1 (n.factorization p), 0 ≤ c p j ∧ c p j ≤ p - 1) ∧
      x ≡ ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ) [ZMOD n] := by
        exact lemma_canonical_representation_exists n x hn h_not_prime_pow

/-
If the canonical representation sum is not maximal, it is at most S_max n - n.
-/
lemma lemma_canonical_representation_gap (n : ℕ) (c : ℕ → ℕ → ℤ)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (hc : ∀ p ∈ n.factorization.support, ∀ j ∈ Finset.Icc 1 (n.factorization p), 0 ≤ c p j ∧ c p j ≤ p - 1)
    (h_not_max : ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ) ≠ S_max n) :
    ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ) ≤ S_max n - n := by
      -- By definition of $D$, we know that $D \geq \sum_{p \in n.factorization.support} (p - 1) * \binom{n}{p} - \sum_{p \in n.factorization.support} c p j * \binom{n}{p}$.
      set D := (S_max n) - (∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ));
      -- Since $D \neq 0$, there exists some $p \in n.factorization.support$ and $j \in \text{Finset.Icc } 1 (n.factorization p)$ such that $(p - 1 - c p j) * \binom{n}{p^j} > 0$.
      obtain ⟨p, hp_mem, j, hj_mem, h_pos⟩ : ∃ p ∈ n.factorization.support, ∃ j ∈ Finset.Icc 1 (n.factorization p), (p - 1 - c p j) * (Nat.choose n (p ^ j) : ℤ) > 0 := by
        by_cases hD_zero : D = 0;
        · exact False.elim <| h_not_max <| sub_eq_zero.mp hD_zero ▸ rfl;
        · contrapose! hD_zero;
          exact sub_eq_zero_of_eq <| by rw [ show S_max n = ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 ( n.factorization p ), ( p - 1 ) * ( Nat.choose n ( p ^ j ) : ℤ ) from lemma_S_max_def n ] ; exact Finset.sum_congr rfl fun p hp => Finset.sum_congr rfl fun j hj => by nlinarith [ hD_zero p hp j hj, hc p hp j hj, Nat.choose_pos ( show p ^ j ≤ n from Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by specialize h_not_prime_pow p 0; aesop ) ) ( Nat.dvd_trans ( pow_dvd_pow _ <| Finset.mem_Icc.mp hj |>.2 ) <| Nat.ordProj_dvd _ _ ) ) ] ;
      -- Since $(p - 1 - c p j) * \binom{n}{p^j} > 0$, we have $D \geq \binom{n}{p^j}$.
      have h_D_ge_binom : D ≥ (Nat.choose n (p ^ j) : ℤ) := by
        have h_D_ge_binom : D ≥ (p - 1 - c p j) * (Nat.choose n (p ^ j) : ℤ) := by
          have hD_ge_term : D ≥ ∑ q ∈ n.factorization.support, ∑ i ∈ Finset.Icc 1 (n.factorization q), (q - 1 - c q i) * (Nat.choose n (q ^ i) : ℤ) := by
            simp +zetaDelta at *;
            simp +decide [ sub_mul, Finset.sum_sub_distrib, S_max ] ;
            unfold K; norm_num [ Finset.sum_add_distrib, mul_comm ] ;
            rw [ ← Finset.sum_add_distrib ] ; exact Finset.sum_le_sum fun p hp => by rw [ Finset.mul_sum _ _ _ ] ; exact by rw [ ← Finset.sum_add_distrib ] ; exact Finset.sum_le_sum fun i hi => by rw [ Nat.cast_sub ( Nat.one_le_iff_ne_zero.mpr <| Nat.ne_of_gt <| Nat.pos_of_mem_primeFactors hp ) ] ; ring_nf; norm_num;
          refine le_trans ?_ hD_ge_term;
          refine' le_trans _ ( Finset.single_le_sum ( fun q hq => _ ) hp_mem );
          · exact le_trans ( by aesop ) ( Finset.single_le_sum ( fun i hi => mul_nonneg ( sub_nonneg.2 <| by linarith [ hc p hp_mem i hi ] ) <| Nat.cast_nonneg _ ) hj_mem );
          · exact Finset.sum_nonneg fun i hi => mul_nonneg ( by linarith [ hc q hq i hi ] ) ( Nat.cast_nonneg _ );
        nlinarith [ hc p hp_mem j hj_mem, show ( p : ℤ ) - 1 - c p j ≥ 1 from by nlinarith [ hc p hp_mem j hj_mem ] ];
      -- By lemma_binom_ge_n, we have $\binom{n}{p^j} \geq n$.
      have h_binom_ge_n : (Nat.choose n (p ^ j) : ℤ) ≥ n := by
        apply lemma_binom_ge_n n p j hp_mem (Finset.mem_Icc.mp hj_mem).right h_not_prime_pow;
      linarith

/-
n is in the set of representable integers.
-/
lemma lemma_n_in_representable (n : ℕ)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) :
    (n : ℤ) ∈ Representable n := by
      -- Applying the lemma that states if the sum is congruent to n modulo n, then it is representable.
      apply Classical.byContradiction
      intro h_not_representable
      generalize_proofs at *; (
      -- Applying the lemma that states if the sum is congruent to n modulo n, then it is representable. Hence, we have a contradiction.
      apply h_not_representable; exact (by
      -- Since $n = \binom{n}{1}$ and $1 < n$, we have $n \in \text{generators } n$.
      have h_n_in_generators : (n : ℤ) ∈ generators_int n := by
        use n
        generalize_proofs at *; (
        rcases n with ( _ | _ | n ) <;> simp_all +decide [ generators ];
        · exact h_not_prime_pow 2 0 Nat.prime_two rfl;
        · exact ⟨ 1, by norm_num, by linarith, by norm_num ⟩)
      generalize_proofs at *; (
      exact AddSubmonoid.subset_closure h_n_in_generators)))

/-
The canonical sum is in the set of representable integers.
-/
lemma lemma_canonical_sum_in_representable (n : ℕ) (c : ℕ → ℕ → ℤ)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (hc : ∀ p ∈ n.factorization.support, ∀ j ∈ Finset.Icc 1 (n.factorization p), 0 ≤ c p j) :
    (∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)) ∈ Representable n := by
      -- By definition of `representable`, if $Y$ is in `representable`, then there exists a coefficient vector $c$ such that $\sum c_i \binom{n}{i} \equiv Y \pmod{n}$ and $\sum c_i \binom{n}{i} \geq \text{target}(n)$.
      apply AddSubmonoid.sum_mem; intro p hp; apply AddSubmonoid.sum_mem; intro j hj; exact (by
      -- Since $c p j$ is non-negative, it can be written as a sum of $c p j$ copies of $1$, each multiplied by $\binom{n}{p^j}$.
      have h_sum : c p j * (Nat.choose n (p ^ j) : ℤ) = ∑ i ∈ Finset.range (c p j).toNat, (Nat.choose n (p ^ j) : ℤ) := by
        simp +decide [ Int.toNat_of_nonneg ( hc p hp j hj ) ];
      -- Since each term in the sum is a generator, and the sum is a finite sum of generators, it must be in the additive submonoid.
      have h_generator : (Nat.choose n (p ^ j) : ℤ) ∈ generators_int n := by
        apply Set.mem_image_of_mem; exact (by
        use p ^ j
        generalize_proofs at *; (
        exact ⟨ Nat.one_le_pow _ _ ( Nat.pos_of_mem_primeFactors hp ), lt_of_le_of_ne ( Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop ) ) ( Nat.dvd_trans ( pow_dvd_pow _ ( Finset.mem_Icc.mp hj |>.2 ) ) ( Nat.ordProj_dvd _ _ ) ) ) ( Ne.symm ( h_not_prime_pow p j ( Nat.prime_of_mem_primeFactors hp ) ) ), rfl ⟩));
      exact h_sum.symm ▸ AddSubmonoid.sum_mem _ fun i hi => AddSubmonoid.subset_closure h_generator);

/-
Any integer greater than target n is representable.
-/
theorem upper_bound (n : ℕ) (x : ℤ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (hx : x > target n) :
    x ∈ Representable n := by
      -- Let's obtain the canonical representation of x modulo n.
      obtain ⟨c, hc⟩ : ∃ c : ℕ → ℕ → ℤ,
        (∀ p ∈ n.factorization.support, ∀ j ∈ Finset.Icc 1 (n.factorization p), 0 ≤ c p j ∧ c p j ≤ p - 1) ∧
        x ≡ ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ) [ZMOD n] := by
          exact lemma_canonical_representation_exists_v2 n x hn h_not_prime_pow;
      -- Since S is representable and n is representable, S + k * n is representable.
      have h_representable : (∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)) ∈ Representable n ∧ (n : ℤ) ∈ Representable n := by
        exact ⟨ by exact lemma_canonical_sum_in_representable n c h_not_prime_pow fun p hp j hj => hc.1 p hp j hj |>.1, by exact lemma_n_in_representable n h_not_prime_pow ⟩;
      obtain ⟨ k, hk ⟩ := hc.2.symm.dvd;
      -- Since $k$ is non-negative, we can write $x$ as $S + k * n$.
      have hk_nonneg : 0 ≤ k := by
        by_cases hS_max : ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ) = S_max n;
        · nlinarith [ show ( n : ℤ ) > 0 from Nat.cast_pos.mpr ( Nat.pos_of_ne_zero hn ), lemma_target_eq_S_max_sub_n n ];
        · have hS_le : ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ) ≤ S_max n - n := by
            exact lemma_canonical_representation_gap n c h_not_prime_pow hc.1 hS_max;
          nlinarith [ show ( n : ℤ ) > 0 by positivity, show ( target n : ℤ ) = S_max n - n by exact lemma_target_eq_S_max_sub_n n ];
      -- Since $k$ is non-negative, we can write $x$ as $S + k * n$ and use the fact that $S$ and $n$ are representable.
      have hx_representable : (∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)) + k * (n : ℤ) ∈ Representable n := by
        have hx_representable : ∀ m : ℕ, (∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)) + m * (n : ℤ) ∈ Representable n := by
          intro m; induction m <;> simp_all +decide [ add_mul, ← add_assoc ] ;
          exact AddSubmonoid.add_mem _ ‹_› h_representable.2;
        cases k <;> aesop;
      convert hx_representable using 1 ; linarith

/-
A number is a PrimePowerSum if it is a non-negative linear combination of prime power binomials.
-/
def IsPrimePowerSum (n : ℕ) (S : ℤ) : Prop :=
  ∃ c : ℕ → ℕ → ℤ, (∀ p ∈ n.factorization.support, ∀ j ∈ Finset.Icc 1 (n.factorization p), 0 ≤ c p j) ∧
  S = ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)

/-
If a linear combination $cA + S_{higher}$ is divisible by $p^{v+1}$, where $S_{higher}$ is already divisible by $p^{v+1}$, $A$ has valuation $v$, and $c$ is small, then $c$ must be zero.
-/
lemma lemma_coeff_vanishes_of_valuation_bound (p : ℕ) (c : ℤ) (A : ℤ) (S_higher : ℤ) (v : ℕ)
    (hp : p.Prime)
    (hc_nonneg : 0 ≤ c) (hc_lt : c < p)
    (hA_pos : A > 0)
    (hA_val : padicValNat p A.toNat = v)
    (hS_higher_dvd : (p : ℤ) ^ (v + 1) ∣ S_higher)
    (h_sum_dvd : (p : ℤ) ^ (v + 1) ∣ c * A + S_higher) :
    c = 0 := by
      -- Since $p$ does not divide $A$, if $p$ divides $cA$, then $p$ must divide $c$.
      have h_div_c : (p : ℤ) ∣ c := by
        -- Since $p^{v+1}$ divides $cA + S_{higher}$ and $p^{v+1}$ divides $S_{higher}$, it follows that $p^{v+1}$ divides $cA$.
        have h_div_cA : (p : ℤ) ^ (v + 1) ∣ c * A := by
          simpa using dvd_sub h_sum_dvd hS_higher_dvd;
        -- Since $p^{v+1}$ divides $cA$ and $p$ does not divide $A$, it follows that $p^{v+1}$ must divide $c$.
        have h_div_c : (p : ℤ) ^ (v + 1) ∣ c * A → ¬(p : ℤ) ^ (v + 1) ∣ A → (p : ℤ) ∣ c := by
          intros h_div_cA h_not_div_A
          have h_div_c : (p : ℤ) ∣ c := by
            contrapose! h_not_div_A;
            exact ( Int.dvd_of_dvd_mul_right_of_gcd_one h_div_cA <| by simpa [ Int.gcd, Int.natAbs_pow ] using hp.coprime_iff_not_dvd.mpr fun h => h_not_div_A <| Int.natCast_dvd.mpr h )
          exact h_div_c;
        apply h_div_c h_div_cA; intro h; have := Int.natAbs_dvd_natAbs.mpr h; simp_all +decide [ Int.natAbs_pow ] ;
        have := Nat.factorization_le_iff_dvd ( by aesop ) ( by aesop ) |>.2 this ; simp_all +decide [ Nat.Prime.factorization ] ;
        replace := this p ; simp_all +decide [ Nat.factorization ] ;
        cases A <;> aesop;
      exact le_antisymm ( le_of_not_gt fun h => by linarith [ Int.le_of_dvd ( by linarith ) h_div_c ] ) hc_nonneg

/-
In a SuperSequence, the sum of terms with index less than $j$ is divisible by $p^{m-j+1}$.
-/
lemma lemma_super_sequence_sum_divisible_by_valuation (p m j : ℕ) (A : ℕ → ℤ) (c : ℕ → ℤ)
    (hA : IsSuperSequence p m A)
    (hj : j ∈ Finset.Icc 1 m) :
    (p : ℤ) ^ (m - j + 1) ∣ ∑ i ∈ Finset.Icc 1 (j - 1), c i * A i := by
      refine' Finset.dvd_sum fun i hi => dvd_mul_of_dvd_right _ _;
      -- Since $A$ is a SuperSequence, we have $v_p(A_i) = m - i$.
      have h_val : padicValNat p (A i).toNat = m - i := by
        exact hA.1 i ( Finset.mem_Icc.mpr ⟨ by linarith [ Finset.mem_Icc.mp hi ], by linarith [ Finset.mem_Icc.mp hi, Finset.mem_Icc.mp hj, Nat.sub_le j 1 ] ⟩ );
      have h_div : (p : ℤ) ^ (m - i) ∣ A i := by
        have h_div : (p : ℕ) ^ (m - i) ∣ Int.toNat (A i) := by
          rw [ ← h_val ];
          exact pow_padicValNat_dvd;
        convert Int.natCast_dvd_natCast.mpr h_div using 1;
        · norm_cast;
        · rw [ Int.toNat_of_nonneg ( by linarith [ hA.2.2 i ( Finset.mem_Icc.mpr ⟨ by linarith [ Finset.mem_Icc.mp hi ], by linarith [ Finset.mem_Icc.mp hi, Finset.mem_Icc.mp hj, Nat.sub_le j 1 ] ⟩ ) ] ) ];
      exact dvd_trans ( pow_dvd_pow _ ( by norm_num at *; omega ) ) h_div

/-
If a SuperSequence sum is divisible by p^k, then coefficients for terms with valuation < k must be zero.
-/
lemma lemma_super_sequence_valuation_implication (p m : ℕ) (A : ℕ → ℤ) (c : ℕ → ℤ)
    (hp : p.Prime) (hm : m ≥ 1)
    (hA : IsSuperSequence p m A)
    (hc : ∀ j ∈ Finset.Icc 1 m, 0 ≤ c j ∧ c j ≤ p - 1)
    (k : ℕ)
    (h_cong : ∑ j ∈ Finset.Icc 1 m, c j * A j ≡ 0 [ZMOD p ^ k]) :
    ∀ j ∈ Finset.Icc 1 m, m - j < k → c j = 0 := by
      -- Let $S = \{j \in \{1, \dots, m\} \mid m-j < k \land c_j \ne 0\}$.
      set S := Finset.filter (fun j => m - j < k ∧ c j ≠ 0) (Finset.Icc 1 m) with hS_def;
      by_contra h_nonempty_S;
      -- Let $j_{\text{max}} = \max S$.
      obtain ⟨j_max, hj_max⟩ : ∃ j_max ∈ S, ∀ j ∈ S, j ≤ j_max := by
        exact ⟨ Finset.max' S ( Finset.nonempty_of_ne_empty ( by aesop ) ), Finset.max'_mem _ _, fun j hj => Finset.le_max' _ _ hj ⟩;
      -- By `lemma_super_sequence_sum_divisible_by_valuation`, $p^{m-j_{max}+1} \mid S_{prev}$.
      have h_S_prev_div : (p : ℤ) ^ (m - j_max + 1) ∣ ∑ i ∈ Finset.Icc 1 (j_max - 1), c i * A i := by
        exact lemma_super_sequence_sum_divisible_by_valuation p m j_max A c hA ( Finset.mem_Icc.mpr ⟨ by linarith [ Finset.mem_Icc.mp ( Finset.mem_filter.mp hj_max.1 |>.1 ) ], by linarith [ Finset.mem_Icc.mp ( Finset.mem_filter.mp hj_max.1 |>.1 ) ] ⟩ );
      -- The total sum is divisible by $p^k$. Since $m-j_{max} < k$, we have $m-j_{max}+1 \le k$, so $p^{m-j_{max}+1} \mid p^k$.
      have h_total_div : (p : ℤ) ^ (m - j_max + 1) ∣ ∑ i ∈ Finset.Icc 1 m, c i * A i := by
        exact dvd_trans ( pow_dvd_pow _ ( by linarith [ Finset.mem_filter.mp hj_max.1, Nat.sub_add_cancel ( show j_max ≤ m from Finset.mem_Icc.mp ( Finset.mem_filter.mp hj_max.1 |>.1 ) |>.2 ) ] ) ) ( Int.modEq_zero_iff_dvd.mp h_cong );
      -- This implies $p^{m-j_{max}+1} \mid c_{j_{max}} A_{j_{max}} + S_{prev}$.
      have h_div : (p : ℤ) ^ (m - j_max + 1) ∣ c j_max * A j_max + ∑ i ∈ Finset.Icc 1 (j_max - 1), c i * A i := by
        have h_div : (p : ℤ) ^ (m - j_max + 1) ∣ ∑ i ∈ Finset.Icc 1 m, c i * A i - ∑ i ∈ Finset.Icc (j_max + 1) m, c i * A i := by
          refine' dvd_sub h_total_div _;
          have h_div : ∀ i ∈ Finset.Icc (j_max + 1) m, c i = 0 := by
            simp +zetaDelta at *;
            grind;
          exact Finset.dvd_sum fun i hi => by rw [ h_div i hi ] ; norm_num;
        convert h_div using 1;
        erw [ Finset.sum_Ico_eq_sub _ _, Finset.sum_Ico_eq_sub _ _ ] <;> norm_num;
        erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ ] ; ring_nf;
        · cases j_max <;> simp_all +decide [ Finset.sum_range_succ ] ; ring;
        · exact Finset.mem_Icc.mp ( Finset.mem_filter.mp hj_max.1 |>.1 ) |>.2;
      -- We apply `lemma_coeff_vanishes_of_valuation_bound` with $v = m-j_{max}$, $A = A_{j_{max}}$, $c = c_{j_{max}}$, $S_{higher} = S_{prev}$.
      have h_coeff_vanishes : c j_max = 0 := by
        apply lemma_coeff_vanishes_of_valuation_bound p (c j_max) (A j_max) (∑ i ∈ Finset.Icc 1 (j_max - 1), c i * A i) (m - j_max) hp (hc j_max (Finset.mem_filter.mp hj_max.left |>.1) |>.1) (by
        linarith [ hc j_max ( Finset.mem_filter.mp hj_max.1 |>.1 ) ]) (by
        exact hA.2.2 j_max ( Finset.mem_Icc.mpr ⟨ by linarith [ Finset.mem_Icc.mp ( Finset.mem_filter.mp hj_max.1 |>.1 ) ], by linarith [ Finset.mem_Icc.mp ( Finset.mem_filter.mp hj_max.1 |>.1 ) ] ⟩ )) (by
        exact hA.1 j_max ( Finset.mem_filter.mp hj_max.1 |>.1 )) (by
        exact h_S_prev_div) (by
        exact h_div);
      exact Finset.mem_filter.mp hj_max.1 |>.2.2 h_coeff_vanishes

/-
The p-adic valuation of binom(n, m) is at least v_p(n) - v_p(m).
-/
lemma lemma_valuation_binom_lower_bound (n m p : ℕ)
    (hp : p.Prime)
    (hm : m > 0)
    (hn : n ≥ m) :
    padicValNat p (Nat.choose n m) ≥ padicValNat p n - padicValNat p m := by
      have h_identity : padicValNat p (m * Nat.choose n m) = padicValNat p n + padicValNat p (Nat.choose (n - 1) (m - 1)) := by
        have h_identity : m * Nat.choose n m = n * Nat.choose (n - 1) (m - 1) := by
          cases n <;> cases m <;> simp_all +decide [ Nat.succ_mul_choose_eq ];
          ring;
        haveI := Fact.mk hp; rw [ h_identity, padicValNat.mul ] ; aesop;
        exact ne_of_gt <| Nat.choose_pos <| by omega;
      have h_identity : padicValNat p (m * Nat.choose n m) = padicValNat p m + padicValNat p (Nat.choose n m) := by
        haveI := Fact.mk hp; rw [ padicValNat.mul ( by positivity ) ( Nat.ne_of_gt ( Nat.choose_pos hn ) ) ] ;
      grind

/-
The sum of $(p-1)\binom{n}{p^j}$ up to $k$ is less than $p\binom{n}{p^k}$.
-/
lemma lemma_sum_super_sequence_bound (n p k : ℕ)
    (hp : p ∈ n.factorization.support)
    (hk : 1 ≤ k) (hk_le : k ≤ n.factorization p)
    (h_not_prime_pow : ∀ q l, Nat.Prime q → n ≠ q ^ l) :
    ∑ j ∈ Finset.Icc 1 k, (p - 1) * (Nat.choose n (p ^ j) : ℤ) < p * (Nat.choose n (p ^ k) : ℤ) := by
      -- Apply the super-increasing property repeatedly.
      have h_super_increasing : ∀ j ∈ Finset.Icc 1 (k - 1), (Nat.choose n (p ^ (j + 1)) : ℤ) > (p - 1) * (∑ l ∈ Finset.Icc 1 j, (Nat.choose n (p ^ l) : ℤ)) := by
        intro j hj; apply lemma_super_increasing; aesop;
        · linarith [ Finset.mem_Icc.mp hj ];
        · exact lt_of_le_of_lt ( Finset.mem_Icc.mp hj |>.2 ) ( Nat.lt_of_lt_of_le ( Nat.pred_lt ( ne_bot_of_gt hk ) ) hk_le );
        · grind;
      rcases k with ( _ | k ) <;> simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ];
      induction' k with k ih <;> simp_all +decide [ Finset.sum_Ioc_succ_top, pow_succ' ];
      · exact mul_lt_mul_of_pos_right ( sub_lt_self _ zero_lt_one ) ( Nat.cast_pos.mpr ( Nat.choose_pos ( Nat.le_of_dvd ( Nat.pos_of_ne_zero hp.2.2 ) hp.2.1 ) ) );
      · have := h_super_increasing ( k + 1 ) ( Nat.succ_pos _ ) ( by linarith ) ; simp_all +decide [ Finset.sum_Ioc_succ_top, pow_succ' ] ;
        rw [ ← Finset.mul_sum _ _ _ ] ; nlinarith [ h_super_increasing 1 zero_lt_one ( by linarith ), h_super_increasing ( k + 1 ) ( Nat.succ_pos _ ) ( by linarith ), hp.1.two_le ] ;

/-
$p^k \binom{n}{p^k}$ is greater than the sum of $(p-1)\binom{n}{p^j}$ up to $k$.
-/
lemma lemma_prime_pow_binom_bound (n p k : ℕ)
    (hp : p ∈ n.factorization.support)
    (hk : 1 ≤ k) (hk_le : k ≤ n.factorization p)
    (h_not_prime_pow : ∀ q l, Nat.Prime q → n ≠ q ^ l) :
    (p ^ k : ℤ) * (Nat.choose n (p ^ k) : ℤ) ≥ ∑ j ∈ Finset.Icc 1 k, (p - 1) * (Nat.choose n (p ^ j) : ℤ) := by
      -- From `lemma_sum_super_sequence_bound`, we have that $\sum_{j=1}^k (p-1) \binom{n}{p^j} < p \binom{n}{p^k}$.
      have h_sum_lt : ∑ j ∈ Finset.Icc 1 k, (p - 1) * (Nat.choose n (p ^ j) : ℤ) < p * (Nat.choose n (p ^ k) : ℤ) := by
        convert lemma_sum_super_sequence_bound n p k hp hk hk_le h_not_prime_pow using 1;
      exact h_sum_lt.le.trans ( by exact mul_le_mul_of_nonneg_right ( mod_cast Nat.le_self_pow ( by linarith ) _ ) ( Nat.cast_nonneg _ ) )

/-
The sum of $c_j \binom{n}{p^j}$ with coefficients $c_j \le p-1$ is bounded by $p^k \binom{n}{p^k}$.
-/
lemma lemma_local_canonical_bound (n p k : ℕ) (c : ℕ → ℤ)
    (hp : p ∈ n.factorization.support)
    (hk : 1 ≤ k) (hk_le : k ≤ n.factorization p)
    (h_not_prime_pow : ∀ q l, Nat.Prime q → n ≠ q ^ l)
    (hc : ∀ j ∈ Finset.Icc 1 k, 0 ≤ c j ∧ c j ≤ p - 1) :
    ∑ j ∈ Finset.Icc 1 k, c j * (Nat.choose n (p ^ j) : ℤ) ≤ (p ^ k : ℤ) * (Nat.choose n (p ^ k) : ℤ) := by
      refine' le_trans ( Finset.sum_le_sum fun i hi => mul_le_mul_of_nonneg_right ( hc i hi |>.2 ) <| Nat.cast_nonneg _ ) _;
      convert lemma_prime_pow_binom_bound n p k hp hk hk_le h_not_prime_pow using 1

/-
Binomial coefficients are increasing for $k \le n/2$.
-/
lemma lemma_binom_monotonicity_k (n k l : ℕ) (hkl : k ≤ l) (hln : l ≤ n / 2) :
    Nat.choose n k ≤ Nat.choose n l := by
      -- We can prove this by induction on $l - k$.
      induction' hkl with l hl ih;
      · rfl;
      · exact le_trans ( ih ( Nat.le_of_succ_le hln ) ) ( Nat.le_of_lt_succ ( by nlinarith [ Nat.div_mul_le_self n 2, Nat.succ_mul_choose_eq n l, Nat.choose_succ_succ n l ] ) )

/-
$p^k \binom{n}{p^k} \le p^l \binom{n}{p^l}$ if $k \le l$ and $p^l \le n/2$.
-/
lemma lemma_prime_pow_inequality (n p k l : ℕ)
    (hk : k ≤ l)
    (hl : p ^ l ≤ n / 2)
    (hp : p ≥ 2) :
    (p ^ k : ℤ) * (Nat.choose n (p ^ k) : ℤ) ≤ (p ^ l : ℤ) * (Nat.choose n (p ^ l) : ℤ) := by
      -- Since $p^k \le p^l$ and $\binom{n}{p^k} \le \binom{n}{p^l}$, multiplying the inequalities gives the desired result.
      have h_combined : (p ^ k : ℤ) ≤ (p ^ l : ℤ) ∧ (Nat.choose n (p ^ k) : ℤ) ≤ (Nat.choose n (p ^ l) : ℤ) := by
        exact ⟨ mod_cast Nat.pow_le_pow_right ( by linarith ) hk, mod_cast lemma_binom_monotonicity_k n ( p ^ k ) ( p ^ l ) ( Nat.pow_le_pow_right ( by linarith ) hk ) ( by linarith [ Nat.div_mul_le_self n 2, Nat.pow_le_pow_right ( by linarith : 1 ≤ p ) hk ] ) ⟩;
      gcongr <;> linarith [ pow_pos ( zero_lt_two.trans_le hp ) k, pow_pos ( zero_lt_two.trans_le hp ) l ] ;

/-
$p^{\min(e, f)} \binom{n}{p^{\min(e, f)}} \le p^f \binom{n}{p^f}$.
-/
lemma lemma_min_term_le_target (n p e f : ℕ)
    (hp : p ≥ 2)
    (hf_le_half : p ^ f ≤ n / 2) :
    (p ^ (min e f) : ℤ) * (Nat.choose n (p ^ (min e f)) : ℤ) ≤ (p ^ f : ℤ) * (Nat.choose n (p ^ f) : ℤ) := by
      cases le_total e f <;> simp_all +decide;
      (expose_names; exact lemma_prime_pow_inequality n p e f h hf_le_half hp)

/-
If $f \le e$ and terms beyond $f$ are zero, the sum is bounded by $p^f \binom{n}{p^f}$.
-/
lemma lemma_sum_le_min_term_case1 (n p e f : ℕ) (c : ℕ → ℤ)
    (hp : p ∈ n.factorization.support)
    (he : e = n.factorization p)
    (hf_le : f ≤ e)
    (hf_pos : 1 ≤ f)
    (h_not_prime_pow : ∀ q l, Nat.Prime q → n ≠ q ^ l)
    (hc : ∀ j ∈ Finset.Icc 1 e, 0 ≤ c j ∧ c j ≤ p - 1)
    (hc_zero : ∀ j ∈ Finset.Icc 1 e, j > f → c j = 0) :
    ∑ j ∈ Finset.Icc 1 e, c j * (Nat.choose n (p ^ j) : ℤ) ≤ (p ^ f : ℤ) * (Nat.choose n (p ^ f) : ℤ) := by
      -- Since $f \le e$, the intervals $[1, f]$ and $[1, e]$ are the same, so the summation can be restricted to $[1, f]$.
      have sum_eq_sum : ∑ j ∈ Finset.Icc 1 e, c j * (Nat.choose n (p ^ j) : ℤ) = ∑ j ∈ Finset.Icc 1 f, c j * (Nat.choose n (p ^ j) : ℤ) := by
        rw [ ← Finset.sum_subset ( Finset.Icc_subset_Icc_right hf_le ) fun x hx₁ hx₂ => by aesop ];
      convert lemma_local_canonical_bound n p f _ _ _ _ _ using 1;
      rotate_left;
      use fun j => if j ∈ Finset.Icc 1 f then c j else 0;
      · assumption;
      · linarith;
      · linarith;
      · exact h_not_prime_pow;
      · simp_all +decide
        exact Or.inl fun j hj₁ hj₂ => hc j hj₁ ( by linarith )

/-
The sum is bounded by $p^e \binom{n}{p^e}$.
-/
lemma lemma_sum_le_min_term_case2 (n p e : ℕ) (c : ℕ → ℤ)
    (hp : p ∈ n.factorization.support)
    (he : e = n.factorization p)
    (h_not_prime_pow : ∀ q l, Nat.Prime q → n ≠ q ^ l)
    (hc : ∀ j ∈ Finset.Icc 1 e, 0 ≤ c j ∧ c j ≤ p - 1) :
    ∑ j ∈ Finset.Icc 1 e, c j * (Nat.choose n (p ^ j) : ℤ) ≤ (p ^ e : ℤ) * (Nat.choose n (p ^ e) : ℤ) := by
      apply_rules [ lemma_local_canonical_bound ];
      · exact he.symm ▸ Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp hp );
      · linarith

/-
The canonical sum is bounded by $p^{\min(e, f)} \binom{n}{p^{\min(e, f)}}$.
-/
lemma lemma_sum_le_min_term (n p e f : ℕ) (c : ℕ → ℤ)
    (hp : p ∈ n.factorization.support)
    (he : e = n.factorization p)
    (h_not_prime_pow : ∀ q l, Nat.Prime q → n ≠ q ^ l)
    (hc : ∀ j ∈ Finset.Icc 1 e, 0 ≤ c j ∧ c j ≤ p - 1)
    (hc_zero : ∀ j ∈ Finset.Icc 1 e, j > f → c j = 0) :
    ∑ j ∈ Finset.Icc 1 e, c j * (Nat.choose n (p ^ j) : ℤ) ≤ (p ^ (min e f) : ℤ) * (Nat.choose n (p ^ (min e f)) : ℤ) := by
      by_cases h_case : f ≤ e;
      · have h_sum_le_min_term_case1 : ∑ j ∈ Finset.Icc 1 e, c j * (Nat.choose n (p ^ j) : ℤ) ≤ (p ^ f : ℤ) * (Nat.choose n (p ^ f) : ℤ) := by
          by_cases hf_pos : 1 ≤ f;
          · apply_rules [ lemma_sum_le_min_term_case1 ];
          · rw [ Finset.sum_eq_zero ] <;> aesop;
        rwa [ min_eq_right h_case ];
      · rw [ min_eq_left ( le_of_not_ge h_case ) ];
        convert lemma_sum_le_min_term_case2 n p e c hp he h_not_prime_pow hc using 1

/-
The canonical sum for prime $p$ is bounded by the decomposition term for $p$.
-/
lemma lemma_term_wise_bound (n m p : ℕ) (c : ℕ → ℤ)
    (hp : p ∈ n.factorization.support)
    (hpm : p ∈ m.factorization.support)
    (hn : 2 * m ≤ n)
    (h_not_prime_pow : ∀ q l, Nat.Prime q → n ≠ q ^ l)
    (hc : ∀ j ∈ Finset.Icc 1 (n.factorization p), 0 ≤ c j ∧ c j ≤ p - 1)
    (hc_zero : ∀ j ∈ Finset.Icc 1 (n.factorization p), j > padicValNat p m → c j = 0) :
    ∑ j ∈ Finset.Icc 1 (n.factorization p), c j * (Nat.choose n (p ^ j) : ℤ) ≤ (p ^ (m.factorization p) : ℤ) * (Nat.choose n (p ^ (m.factorization p)) : ℤ) := by
      have hp_prime : p.Prime := Nat.prime_of_mem_primeFactors hp
      have h_sum_bound : ∑ j ∈ Finset.Icc 1 (n.factorization p), c j * (Nat.choose n (p ^ j) : ℤ) ≤ (p ^ (min (n.factorization p) (m.factorization p)) : ℤ) * (Nat.choose n (p ^ (min (n.factorization p) (m.factorization p))) : ℤ) := by
        apply lemma_sum_le_min_term n p (n.factorization p) (m.factorization p) c hp rfl h_not_prime_pow hc
        intro j hj hj_gt
        apply hc_zero j hj
        rwa [Nat.factorization_def m hp_prime] at hj_gt
      have h_min_bound : (p ^ (min (n.factorization p) (m.factorization p)) : ℤ) * (Nat.choose n (p ^ (min (n.factorization p) (m.factorization p))) : ℤ) ≤ (p ^ (m.factorization p) : ℤ) * (Nat.choose n (p ^ (m.factorization p)) : ℤ) := by
        apply lemma_min_term_le_target n p (n.factorization p) (m.factorization p)
        · exact Nat.Prime.two_le hp_prime
        · have h_div : p ^ (m.factorization p) ∣ m := Nat.ordProj_dvd m p
          have h_le_m : p ^ (m.factorization p) ≤ m := Nat.le_of_dvd (Nat.pos_of_ne_zero (by aesop)) h_div
          have h_m_le_n_half : m ≤ n / 2 := by
            rw [Nat.le_div_iff_mul_le (by norm_num)]
            linarith
          exact le_trans h_le_m h_m_le_n_half
      exact le_trans h_sum_bound h_min_bound

set_option maxHeartbeats 0 in
/-
The canonical sum is bounded by the decomposition sum.
-/
lemma lemma_global_canonical_bound (n m : ℕ) (c : ℕ → ℕ → ℤ)
    (hn : 2 * m ≤ n)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (hc : ∀ p ∈ n.factorization.support, ∀ j ∈ Finset.Icc 1 (n.factorization p), 0 ≤ c p j ∧ c p j ≤ p - 1)
    (hc_zero : ∀ p ∈ n.factorization.support, ∀ j ∈ Finset.Icc 1 (n.factorization p), j > padicValNat p m → c p j = 0) :
    ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ) ≤ DecompositionSum n m := by
      -- The terms where $p \notin m$ contribute $0$ to both the canonical sum and the decomposition sum.
      have h_sum_zero : ∑ p ∈ n.factorization.support \ m.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), (c p j : ℤ) * (Nat.choose n (p ^ j) : ℤ) = 0 := by
        refine Finset.sum_eq_zero fun p hp => Finset.sum_eq_zero fun j hj => mul_eq_zero_of_left ?_ _;
        convert hc_zero p ( by aesop ) j hj _;
        unfold padicValNat; aesop;
      -- The terms where $p \in m$ contribute to both the canonical sum and the decomposition sum. We can apply `lemma_term_wise_bound_v3` to each of these terms.
      have h_sum_nonzero : ∑ p ∈ n.factorization.support ∩ m.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), (c p j : ℤ) * (Nat.choose n (p ^ j) : ℤ) ≤ ∑ p ∈ m.factorization.support, (p ^ (m.factorization p) : ℤ) * (Nat.choose n (p ^ (m.factorization p)) : ℤ) := by
        have h_sum_nonzero : ∀ p ∈ n.factorization.support ∩ m.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), (c p j : ℤ) * (Nat.choose n (p ^ j) : ℤ) ≤ (p ^ (m.factorization p) : ℤ) * (Nat.choose n (p ^ (m.factorization p)) : ℤ) := by
          intros p hp_mem; apply_rules [ lemma_term_wise_bound ] ; aesop;
          · aesop;
          · exact Finset.mem_of_mem_inter_left hp_mem;
          · grind;
        exact le_trans ( Finset.sum_le_sum h_sum_nonzero ) ( Finset.sum_le_sum_of_subset_of_nonneg ( Finset.inter_subset_right ) fun _ _ _ => mul_nonneg ( pow_nonneg ( Nat.cast_nonneg _ ) _ ) ( Nat.cast_nonneg _ ) );
      rw [ ← Finset.sum_inter_add_sum_diff n.factorization.support m.factorization.support ] ; aesop

/-
Definitions of `CanonicalRep` and `CanonicalSumValue` and their properties.
-/
noncomputable def CanonicalRep (n : ℕ) (x : ℤ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) : ℕ → ℕ → ℤ :=
  Classical.choose (lemma_canonical_representation_exists n x hn h_not_prime_pow)

noncomputable def CanonicalSumValue (n : ℕ) (x : ℤ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) : ℤ :=
  let c := CanonicalRep n x hn h_not_prime_pow
  ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)

lemma lemma_canonical_rep_properties (n : ℕ) (x : ℤ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) :
    let c := CanonicalRep n x hn h_not_prime_pow
    (∀ p ∈ n.factorization.support, ∀ j ∈ Finset.Icc 1 (n.factorization p), 0 ≤ c p j ∧ c p j ≤ p - 1) ∧
    x ≡ CanonicalSumValue n x hn h_not_prime_pow [ZMOD n] := by
  exact Classical.choose_spec (lemma_canonical_representation_exists n x hn h_not_prime_pow)

set_option maxHeartbeats 0 in
/-
`binom(n, m)` is greater than its canonical sum value.
-/
lemma lemma_binom_ge_canonical (n m : ℕ)
    (hm : 1 ≤ m) (hm_lt : m < n)
    (hn : 2 * m ≤ n)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (h_m_not_prime_pow : ¬ IsPrimePow m) :
    (Nat.choose n m : ℤ) ≥ CanonicalSumValue n (Nat.choose n m) (by linarith) h_not_prime_pow := by
      have := lemma_global_canonical_bound n m
      generalize_proofs at *;
      refine' le_trans ( this _ hn h_not_prime_pow _ _ ) _;
      · exact Classical.choose_spec ( lemma_canonical_representation_exists n _ ‹_› h_not_prime_pow ) |>.1;
      · intros p hp j hj hj_gt
        have h_cong : (∑ j ∈ Finset.Icc 1 (n.factorization p), CanonicalRep n (Nat.choose n m) ‹_› h_not_prime_pow p j * (Nat.choose n (p ^ j) : ℤ)) ≡ (Nat.choose n m : ℤ) [ZMOD p ^ (n.factorization p)] := by
          have h_cong : (∑ q ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization q), CanonicalRep n (Nat.choose n m) ‹_› h_not_prime_pow q j * (Nat.choose n (q ^ j) : ℤ)) ≡ (Nat.choose n m : ℤ) [ZMOD p ^ (n.factorization p)] := by
            have := lemma_canonical_rep_properties n ( Nat.choose n m ) ‹_› h_not_prime_pow;
            exact this.2.symm.of_dvd <| mod_cast Nat.ordProj_dvd _ _;
          rw [ Finset.sum_eq_add_sum_diff_singleton hp ] at h_cong;
          have h_cross_terms_zero : ∀ q ∈ n.factorization.support \ {p}, ∀ j ∈ Finset.Icc 1 (n.factorization q), (Nat.choose n (q ^ j) : ℤ) ≡ 0 [ZMOD p ^ (n.factorization p)] := by
            intros q hq j hj
            apply lemma_cross_term_vanishes n p q j hp (by
            exact Finset.mem_sdiff.mp hq |>.1) (by
            exact fun h => by simp +decide [ h ] at hq;) (by
            linarith [ Finset.mem_Icc.mp hj ]);
          have h_cross_terms_zero : ∑ x ∈ n.factorization.support \ {p}, ∑ j ∈ Finset.Icc 1 (n.factorization x), CanonicalRep n (Nat.choose n m) ‹_› h_not_prime_pow x j * (Nat.choose n (x ^ j) : ℤ) ≡ 0 [ZMOD p ^ (n.factorization p)] := by
            exact Int.modEq_zero_iff_dvd.mpr <| Finset.dvd_sum fun q hq => Finset.dvd_sum fun j hj => dvd_mul_of_dvd_right ( Int.dvd_of_emod_eq_zero <| h_cross_terms_zero q hq j hj ) _;
          simpa using h_cong.sub h_cross_terms_zero;
        have h_val : padicValNat p (Nat.choose n m) ≥ n.factorization p - padicValNat p m := by
          have h_val : padicValNat p (Nat.choose n m) ≥ padicValNat p n - padicValNat p m := by
            apply lemma_valuation_binom_lower_bound n m p (by
            exact Nat.prime_of_mem_primeFactors hp) (by
            linarith) (by
            linarith)
          generalize_proofs at *;
          convert h_val using 1;
          rw [ Nat.factorization_def ] ; aesop
        generalize_proofs at *;
        have := lemma_super_sequence_valuation_implication p (n.factorization p) (fun j => (Nat.choose n (p ^ j) : ℤ)) (fun j => CanonicalRep n (Nat.choose n m) ‹_› h_not_prime_pow p j) (by
        exact Nat.prime_of_mem_primeFactors hp) (by
        exact Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp hp )) (by
        exact lemma_binom_is_super_sequence n p hp h_not_prime_pow) (by
        exact fun j hj => Classical.choose_spec ( lemma_canonical_representation_exists n ( Nat.choose n m ) ‹_› h_not_prime_pow ) |>.1 p hp j hj |> fun h => ⟨ h.1, h.2 ⟩) (n.factorization p - padicValNat p m) (by
        refine' h_cong.of_dvd _ |> Int.ModEq.trans <| Int.modEq_zero_iff_dvd.mpr _;
        · exact pow_dvd_pow _ ( Nat.sub_le _ _ );
        · norm_cast
          generalize_proofs at *;
          rw [ ← Nat.factorization_le_iff_dvd ] <;> norm_num;
          · intro q; by_cases hq : p = q <;> simp_all +decide
            convert h_val using 1;
            rw [ Nat.factorization_def ] ; aesop;
          · aesop;
          · exact Nat.ne_of_gt <| Nat.choose_pos hm_lt.le) j hj (by
        exact Nat.sub_lt_sub_left ( by linarith [ Finset.mem_Icc.mp hj ] ) hj_gt)
        generalize_proofs at *;
        exact this;
      · convert lemma_decomposition_inequality n m hm hm_lt hn h_not_prime_pow h_m_not_prime_pow |> le_trans <| le_rfl using 1

/-
The canonical sum value is a Prime Power Sum (a linear combination of prime power binomials with non-negative coefficients).
-/
lemma lemma_canonical_is_pps (n : ℕ) (x : ℤ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) :
    IsPrimePowerSum n (CanonicalSumValue n x hn h_not_prime_pow) := by
      exact ⟨ _, fun p hp j hj => ( lemma_canonical_rep_properties n x hn h_not_prime_pow ) |>.1 p hp j hj |>.1, rfl ⟩

/-
The sum of two Prime Power Sums is a Prime Power Sum.
-/
lemma lemma_sum_is_pps (n : ℕ) (y1 y2 : ℤ)
    (h1 : IsPrimePowerSum n y1)
    (h2 : IsPrimePowerSum n y2) :
    IsPrimePowerSum n (y1 + y2) := by
      obtain ⟨ c1, hc1, rfl ⟩ := h1
      obtain ⟨ c2, hc2, rfl ⟩ := h2;
      exact ⟨ fun p j => c1 p j + c2 p j, fun p hp j hj => add_nonneg ( hc1 p hp j hj ) ( hc2 p hp j hj ), by simp +decide [ Finset.sum_add_distrib, add_mul ] ⟩

/-
The binomial coefficient $\binom{n}{p^k}$ is a Prime Power Sum.
-/
lemma lemma_binom_basis_is_pps (n p k : ℕ)
    (hp : p ∈ n.factorization.support)
    (hk : 1 ≤ k) (hk_le : k ≤ n.factorization p) :
    IsPrimePowerSum n (Nat.choose n (p ^ k)) := by
      -- We can represent binom(n, p^k) as a Prime Power Sum by choosing the coefficients appropriately.
      use fun q j => if q = p ∧ j = k then 1 else 0;
      rw [ Finset.sum_eq_single p ] <;> aesop

/-
Zero is a Prime Power Sum.
-/
lemma lemma_zero_is_pps (n : ℕ) :
    IsPrimePowerSum n 0 := by
      exact ⟨ fun _ _ => 0, fun _ _ _ _ => by norm_num, by norm_num ⟩

/-
If $m$ is not a prime power and $2m \le n$, then $\binom{n}{m}$ can be reduced to a Prime Power Sum.
-/
lemma lemma_generator_reduction_case_le_half (n m : ℕ)
    (hm_ge_1 : 1 ≤ m) (hm_lt_n : m < n)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (h_m_not_prime_pow : ¬ IsPrimePow m)
    (h_le_half : 2 * m ≤ n) :
    ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ Nat.choose n m ∧ y ≡ Nat.choose n m [ZMOD n] := by
      -- By Lemma~\ref{lemma:canonical_is_pps}, the canonical sum value is a Prime Power Sum. We need to show it satisfies the congruence.
      have h_cong : (CanonicalSumValue n (Nat.choose n m) (by linarith) h_not_prime_pow) ≡ (Nat.choose n m : ℤ) [ZMOD n] := by
        exact lemma_canonical_rep_properties n _ ( by linarith ) h_not_prime_pow |>.2.symm;
      exact ⟨ _, lemma_canonical_is_pps _ _ ( by linarith ) h_not_prime_pow, lemma_binom_ge_canonical _ _ hm_ge_1 hm_lt_n h_le_half h_not_prime_pow h_m_not_prime_pow, h_cong ⟩

/-
If $x$ is divisible by $q^{v_q(n)}$, then the $q$-components of its canonical representation are all zero.
-/
lemma lemma_canonical_sum_zero_of_divisible (n : ℕ) (x : ℤ) (q : ℕ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (hq : q ∈ n.factorization.support)
    (h_div : x ≡ 0 [ZMOD q ^ (n.factorization q)]) :
    ∀ j ∈ Finset.Icc 1 (n.factorization q), CanonicalRep n x hn h_not_prime_pow q j = 0 := by
      -- Since the sum of the terms for q is congruent to 0 modulo q^{v_q(n)}, and each term is divisible by q^{v_q(n)-j}, it follows that each c_{q,j} must be zero.
      have h_sum_zero : ∑ j ∈ Finset.Icc 1 (n.factorization q), CanonicalRep n x hn h_not_prime_pow q j * (Nat.choose n (q ^ j) : ℤ) ≡ 0 [ZMOD q ^ (n.factorization q)] := by
        have h_sum_zero : ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), CanonicalRep n x hn h_not_prime_pow p j * (Nat.choose n (p ^ j) : ℤ) ≡ x [ZMOD q ^ (n.factorization q)] := by
          have h_sum_zero : ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), CanonicalRep n x hn h_not_prime_pow p j * (Nat.choose n (p ^ j) : ℤ) ≡ x [ZMOD n] := by
            exact Classical.choose_spec ( lemma_canonical_representation_exists n x hn h_not_prime_pow ) |>.2.symm;
          exact h_sum_zero.of_dvd <| mod_cast Nat.ordProj_dvd _ _;
        have h_sum_zero : ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), CanonicalRep n x hn h_not_prime_pow p j * (Nat.choose n (p ^ j) : ℤ) ≡ ∑ j ∈ Finset.Icc 1 (n.factorization q), CanonicalRep n x hn h_not_prime_pow q j * (Nat.choose n (q ^ j) : ℤ) [ZMOD q ^ (n.factorization q)] := by
          exact lemma_total_sum_congruence n (CanonicalRep n x hn h_not_prime_pow) q hq;
        exact h_sum_zero.symm.trans ( by simpa using ‹∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 ( n.factorization p ), CanonicalRep n x hn h_not_prime_pow p j * ↑ ( n.choose ( p ^ j ) ) ≡ x [ZMOD ↑q ^ n.factorization q]›.trans h_div );
      -- By `lemma_super_sequence_valuation_implication`, if the sum is divisible by $q^{v_q(n)}$, then each coefficient $c_{q,j}$ must be zero.
      intros j hj
      have h_coeff_zero : ∀ k ≤ n.factorization q, (∑ j ∈ Finset.Icc 1 (n.factorization q), CanonicalRep n x hn h_not_prime_pow q j * (Nat.choose n (q ^ j) : ℤ)) ≡ 0 [ZMOD q ^ k] → ∀ j ∈ Finset.Icc 1 (n.factorization q), n.factorization q - j < k → CanonicalRep n x hn h_not_prime_pow q j = 0 := by
        intros k hk h_sum_zero j hj hjk;
        apply lemma_super_sequence_valuation_implication q ( n.factorization q ) ( fun j => ( Nat.choose n ( q ^ j ) : ℤ ) ) ( fun j => CanonicalRep n x hn h_not_prime_pow q j ) ( Nat.prime_of_mem_primeFactors hq ) ( by linarith [ Finset.mem_Icc.mp hj ] ) ( by
          exact lemma_binom_is_super_sequence n q hq h_not_prime_pow ) ( by
          exact fun j hj => lemma_canonical_rep_properties n x hn h_not_prime_pow |>.1 q hq j hj |> fun h => ⟨ h.1, by linarith [ h.2, Nat.sub_add_cancel ( show 1 ≤ q from Nat.pos_of_mem_primeFactors hq ) ] ⟩ ; ) k h_sum_zero j hj hjk;
      exact h_coeff_zero _ le_rfl h_sum_zero _ hj ( by norm_num at *; omega )

/-
If $p^k \le n/2$ and $k > v_p(n)$, then $\binom{n}{p^k} \ge p^{v_p(n)} \binom{n}{p^{v_p(n)}}$.
-/
lemma lemma_binom_prime_pow_lower_bound (n p k : ℕ)
    (hp : p ∈ n.factorization.support)
    (hk : k > n.factorization p)
    (hk_le_half : p ^ k ≤ n / 2)
    (h_not_prime_pow : ∀ q l, Nat.Prime q → n ≠ q ^ l) :
    (Nat.choose n (p ^ k) : ℤ) ≥ (p ^ (n.factorization p) : ℤ) * (Nat.choose n (p ^ (n.factorization p)) : ℤ) := by
      -- By monotonicity (`lemma_binom_monotonicity_k`), $\binom{n}{p^k} \ge \binom{n}{p^{e+1}}$.
      have h_mono : (Nat.choose n (p ^ k) : ℤ) ≥ (Nat.choose n (p ^ (n.factorization p + 1)) : ℤ) := by
        have h_mono : p ^ (n.factorization p + 1) ≤ p ^ k ∧ p ^ k ≤ n / 2 := by
          exact ⟨ pow_le_pow_right₀ ( Nat.Prime.pos ( Nat.prime_of_mem_primeFactors hp ) ) hk, hk_le_half ⟩
        generalize_proofs at *; (
        have h_mono : ∀ {a b : ℕ}, a ≤ b → b ≤ n / 2 → (Nat.choose n a : ℤ) ≤ (Nat.choose n b : ℤ) := by
          intros a b hab hb; exact_mod_cast lemma_binom_monotonicity_k n a b hab hb;
        generalize_proofs at *; (
        grind))
      generalize_proofs at *; (
      -- Apply `lemma2` with $x=p$ and $y=p^e$.
      have h_lemma2 : (Nat.choose n (p ^ (n.factorization p + 1)) : ℤ) ≥ p * (Nat.choose n p : ℤ) + (p ^ n.factorization p : ℤ) * (Nat.choose n (p ^ n.factorization p) : ℤ) := by
        have h_lemma2 : (Nat.choose n (p * p ^ n.factorization p) : ℤ) ≥ p * (Nat.choose n p : ℤ) + (p ^ n.factorization p : ℤ) * (Nat.choose n (p ^ n.factorization p) : ℤ) := by
          have h_cond : p ≥ 2 ∧ p ^ n.factorization p ≥ p ∧ n ≥ 2 * p * p ^ n.factorization p := by
            have h_cond : p ≥ 2 ∧ p ^ n.factorization p ≥ p ∧ p ^ (n.factorization p + 1) ≤ n / 2 := by
              exact ⟨ Nat.Prime.two_le ( Nat.prime_of_mem_primeFactors hp ), Nat.le_self_pow ( by linarith [ Nat.pos_of_ne_zero ( show n.factorization p ≠ 0 from Finsupp.mem_support_iff.mp hp ) ] ) _, le_trans ( pow_le_pow_right₀ ( Nat.Prime.pos ( Nat.prime_of_mem_primeFactors hp ) ) ( by linarith ) ) hk_le_half ⟩ ;
            generalize_proofs at *; (
            grind)
          have := @lemma2 n p ( p ^ n.factorization p ) ?_ ?_ ?_ ?_ <;> norm_cast at * ; aesop
          generalize_proofs at *; (
          grind);
          grind
        generalize_proofs at *; (
        simpa only [ pow_succ' ] using h_lemma2)
      generalize_proofs at *; (
      exact le_trans ( le_add_of_nonneg_left <| by positivity ) ( h_lemma2.trans h_mono ) |> le_trans <| by norm_num;))

/-
If $m$ is a prime power, the canonical sum for $\binom{n}{m}$ only has terms for the prime factor of $m$.
-/
lemma lemma_canonical_sum_for_prime_pow_is_local (n m : ℕ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (h_m_prime_pow : IsPrimePow m)
    (hm_lt_n : m < n) :
    CanonicalSumValue n (Nat.choose n m) hn h_not_prime_pow =
    let p := m.minFac
    ∑ j ∈ Finset.Icc 1 (n.factorization p), CanonicalRep n (Nat.choose n m) hn h_not_prime_pow p j * (Nat.choose n (p ^ j) : ℤ) := by
      -- By definition of $IsPrimePow$, there exists a prime $p$ such that $m = p^k$.
      obtain ⟨p, k, hp_prime, rfl⟩ : ∃ p k : ℕ, Nat.Prime p ∧ m = p ^ k := by
        rw [ isPrimePow_nat_iff ] at h_m_prime_pow ; aesop;
      -- Since $m = p^k$, we know that $v_q(m) = 0$ for any prime $q \neq p$.
      have h_val_zero : ∀ q ∈ n.factorization.support, q ≠ p → padicValNat q (p ^ k) = 0 := by
        intro q hq hqp; rw [ padicValNat.eq_zero_of_not_dvd ] ; simp_all +decide [ Nat.Prime.dvd_iff_not_coprime ] ;
        exact Nat.Coprime.pow_right _ ( hq.1.coprime_iff_not_dvd.mpr fun h => hqp <| by have := Nat.prime_dvd_prime_iff_eq hq.1 hp_prime; tauto );
      -- Since $v_q(m) = 0$ for any prime $q \neq p$, the canonical coefficients for $q$ are all zero.
      have h_coeff_zero : ∀ q ∈ n.factorization.support, q ≠ p → ∀ j ∈ Finset.Icc 1 (n.factorization q), CanonicalRep n (Nat.choose n (p ^ k)) hn h_not_prime_pow q j = 0 := by
        intros q hq hqp j hj
        have h_div : (Nat.choose n (p ^ k) : ℤ) ≡ 0 [ZMOD q ^ (n.factorization q)] := by
          -- By Kummer's theorem, the valuation of $\binom{n}{p^k}$ at $q$ is at least $v_q(n)$.
          have h_val_ge : padicValNat q (Nat.choose n (p ^ k)) ≥ padicValNat q n := by
            have h_val_ge : padicValNat q (Nat.choose n (p ^ k)) ≥ padicValNat q n - padicValNat q (p ^ k) := by
              apply lemma_valuation_binom_lower_bound n (p ^ k) q (by
              exact Nat.prime_of_mem_primeFactors hq) (by
              exact pow_pos hp_prime.pos _) (by
              linarith);
            grind;
          -- Since $v_q(\binom{n}{p^k}) \geq v_q(n)$, we have $q^{v_q(n)} \mid \binom{n}{p^k}$.
          have h_div : q ^ (padicValNat q n) ∣ Nat.choose n (p ^ k) := by
            have h_div : q ^ (padicValNat q (Nat.choose n (p ^ k))) ∣ Nat.choose n (p ^ k) := by
              haveI := Fact.mk ( Nat.prime_of_mem_primeFactors hq ) ; rw [ padicValNat_dvd_iff_le ] ; aesop;
            exact dvd_trans ( pow_dvd_pow _ h_val_ge ) h_div;
          convert Int.modEq_zero_iff_dvd.mpr ( Int.natCast_dvd_natCast.mpr h_div ) using 1;
          simp +decide [ Nat.factorization ];
          exact fun h => False.elim <| h <| Nat.prime_of_mem_primeFactors hq;
        have := lemma_canonical_sum_zero_of_divisible n ( Nat.choose n ( p ^ k ) ) q hn h_not_prime_pow hq h_div; aesop;
      -- Apply the hypothesis `h_coeff_zero` to each term in the sum.
      have h_sum_zero : ∑ q ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization q), CanonicalRep n (Nat.choose n (p ^ k)) hn h_not_prime_pow q j * (Nat.choose n (q ^ j) : ℤ) = ∑ j ∈ Finset.Icc 1 (n.factorization p), CanonicalRep n (Nat.choose n (p ^ k)) hn h_not_prime_pow p j * (Nat.choose n (p ^ j) : ℤ) := by
        rw [ Finset.sum_eq_single p ] <;> simp_all +contextual [ Finset.sum_eq_zero_iff_of_nonneg ];
        intro hpn; rw [ Nat.factorization_eq_zero_of_not_dvd hpn ] ; norm_num;
      convert h_sum_zero using 1;
      rcases k with ( _ | k ) <;> simp_all +decide [ Nat.Prime.pow_minFac ];
      exact absurd h_m_prime_pow ( by exact not_isPrimePow_one )

/-
If $m$ is a prime power not dividing $n$, the canonical sum for $\binom{n}{m}$ is bounded by the term for $v_p(n)$.
-/
lemma lemma_canonical_sum_prime_pow_bound (n m : ℕ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (h_m_prime_pow : IsPrimePow m)
    (hm_lt_n : m < n)
    (h_not_dvd : ¬ m ∣ n) :
    CanonicalSumValue n (Nat.choose n m) hn h_not_prime_pow ≤
    let p := m.minFac
    (p ^ (n.factorization p) : ℤ) * (Nat.choose n (p ^ (n.factorization p)) : ℤ) := by
      have := @lemma_canonical_sum_for_prime_pow_is_local n m hn h_not_prime_pow h_m_prime_pow hm_lt_n; ( have := @lemma_canonical_rep_properties n ( Nat.choose n m ) hn h_not_prime_pow; ( simp_all +decide ) );
      by_cases h : Nat.Prime m.minFac ∧ m.minFac ∣ n <;> simp_all +decide [ IsPrimePow ];
      · apply_rules [ lemma_local_canonical_bound ];
        · exact Nat.mem_primeFactors.mpr ⟨ Nat.minFac_prime h.1, h.2, by aesop ⟩;
        · exact Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by aesop ) );
        · norm_num +zetaDelta at *;
        · exact fun j hj => this.1 _ ( Nat.minFac_prime h.1 ) h.2 _ ( Finset.mem_Icc.mp hj |>.1 ) ( Finset.mem_Icc.mp hj |>.2 );
      · by_cases hm : m = 1 <;> simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd ]

/-
If $m=p^k$ is a prime power that does not divide $n$, then $\binom{n}{m}$ is greater than its canonical sum value.
-/
lemma lemma_binom_prime_pow_ge_canonical (n m : ℕ)
    (hm_lt_n : m < n)
    (hm_le_half : 2 * m ≤ n)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (h_m_prime_pow : IsPrimePow m)
    (h_not_dvd : ¬ m ∣ n) :
    (Nat.choose n m : ℤ) ≥ CanonicalSumValue n (Nat.choose n m) (by
      intro h; rw [h] at hm_lt_n; exact Nat.not_lt_zero m hm_lt_n
    ) h_not_prime_pow := by
      -- Let $p = m.minFac$. Since $m$ is a prime power, $m = p^k$ for some $k$.
      obtain ⟨p, k, hp_prime, hp_pow⟩ : ∃ p k, Nat.Prime p ∧ m = p ^ k := by
        rw [ isPrimePow_nat_iff ] at h_m_prime_pow ; aesop;
      -- Since $p^k > v_p(n)$, we have $p^{v_p(n)} \binom{n}{p^{v_p(n)}} \le \binom{n}{p^k}$.
      have h_binom_bound : (p ^ (n.factorization p) : ℤ) * (Nat.choose n (p ^ (n.factorization p)) : ℤ) ≤ (Nat.choose n (p ^ k) : ℤ) := by
        by_cases hp_mem : p ∈ n.factorization.support;
        · have h_binom_bound : (p ^ (n.factorization p) : ℤ) * (Nat.choose n (p ^ (n.factorization p)) : ℤ) ≤ (Nat.choose n (p ^ k) : ℤ) := by
            have h_k_gt_vp : k > n.factorization p := by
              exact not_le.mp fun h => h_not_dvd <| hp_pow.symm ▸ Nat.dvd_trans ( pow_dvd_pow _ h ) ( Nat.ordProj_dvd _ _ )
            have h_p_pow_le_half : p ^ k ≤ n / 2 := by
              grind
            convert lemma_binom_prime_pow_lower_bound n p k hp_mem h_k_gt_vp h_p_pow_le_half ( h_not_prime_pow ) using 1;
          convert h_binom_bound using 1;
        · have h_binom_bound : (Nat.choose n (p ^ k) : ℤ) ≥ (Nat.choose n 2 : ℤ) := by
            have h_binom_bound : ∀ x y : ℕ, 1 ≤ x → x ≤ y → y ≤ n / 2 → (Nat.choose n x : ℤ) ≤ (Nat.choose n y : ℤ) := by
              intros x y hx hy hxy; exact_mod_cast lemma_binom_monotonicity_k n x y hy hxy;
            apply h_binom_bound 2 (p ^ k) (by norm_num) (by
            exact le_trans ( Nat.Prime.two_le hp_prime ) ( Nat.le_self_pow ( by aesop ) _ )) (by
            grind);
          simp_all +decide [ hp_prime.dvd_iff_not_coprime ];
          rw [ Nat.factorization_eq_zero_of_not_dvd ] <;> norm_num;
          · rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.choose ];
            rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.choose ];
            · exact absurd ( h_not_prime_pow 2 1 Nat.prime_two ) ( by decide );
            · linarith [ Nat.choose_pos ( show 2 ≤ n + 2 by linarith ) ];
          · exact fun h => h_not_prime_pow p k hp_prime <| by have := hp_mem ( by have := Nat.gcd_eq_left h; aesop ) ; aesop;
      -- Since $m$ is a prime power, the canonical sum for $\binom{n}{m}$ is bounded by $p^{v_p(n)} \binom{n}{p^{v_p(n)}}$.
      have h_canonical_bound : CanonicalSumValue n (Nat.choose n m) (by linarith) h_not_prime_pow ≤ (p ^ (n.factorization p) : ℤ) * (Nat.choose n (p ^ (n.factorization p)) : ℤ) := by
        convert lemma_canonical_sum_prime_pow_bound n m ( by linarith ) h_not_prime_pow h_m_prime_pow hm_lt_n h_not_dvd using 1;
        cases k <;> simp_all +decide
        rw [ Nat.Prime.pow_minFac ] <;> aesop;
      grind +ring

/-
If $2m > n$, then $\binom{n}{m}$ can be reduced to a PPS.
-/
lemma lemma_generator_reduction_case_gt_half (n m : ℕ)
    (hm_lt_n : m < n)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (h_gt_half : 2 * m > n) :
    ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ Nat.choose n m ∧ y ≡ Nat.choose n m [ZMOD n] := by
      -- Since $2m > n$, we have $2m' < n$ where $m' = n - m$.
      set m' := n - m
      have hm'_lt_m : 2 * m' < n := by
        omega;
      by_cases h_m'_prime_pow : IsPrimePow m';
      · by_cases h_m'_dvd : m' ∣ n;
        · -- If $m'$ divides $n$, then $\binom{n}{m'}$ is a PPS basis element (by `lemma_binom_basis_is_pps`).
          obtain ⟨p, k, hp_prime, hk_pos, hm'_eq⟩ : ∃ p k : ℕ, p.Prime ∧ k ≥ 1 ∧ m' = p ^ k := by
            rw [ isPrimePow_nat_iff ] at h_m'_prime_pow ; aesop;
          use Nat.choose n (p ^ k);
          refine' ⟨ _, _, _ ⟩;
          · apply lemma_binom_basis_is_pps n p k (by
            exact Nat.mem_primeFactors.mpr ⟨ hp_prime, Nat.dvd_trans ( hm'_eq.symm ▸ dvd_pow_self _ ( by linarith ) ) h_m'_dvd, by linarith ⟩) hk_pos (by
            have h_div : p ^ k ∣ n := by
              exact hm'_eq ▸ h_m'_dvd;
            rw [ ← Nat.factorization_le_iff_dvd ] at h_div <;> aesop);
          · rw [ ← hm'_eq, Nat.choose_symm ( by linarith [ Nat.sub_add_cancel hm_lt_n.le ] ) ];
          · rw [ ← hm'_eq, Nat.choose_symm ( Nat.le_of_lt hm_lt_n ) ];
        · -- By `lemma_binom_prime_pow_ge_canonical`, we have $\binom{n}{m'} \ge \text{CanonicalSum}$.
          have h_binom_ge_canonical : (Nat.choose n m' : ℤ) ≥ CanonicalSumValue n (Nat.choose n m') (by
          linarith [ Nat.sub_add_cancel hm_lt_n.le ]) h_not_prime_pow := by
            apply lemma_binom_prime_pow_ge_canonical n m' (by
            grind) (by
            grind) h_not_prime_pow h_m'_prime_pow h_m'_dvd
          generalize_proofs at *;
          refine' ⟨ CanonicalSumValue n ( Nat.choose n m' ) ‹_› h_not_prime_pow, _, _, _ ⟩;
          · (expose_names; exact lemma_canonical_is_pps n (↑(n.choose m')) pf h_not_prime_pow);
          · rw [ Nat.choose_symm ( Nat.le_of_lt hm_lt_n ) ] at * ; linarith;
          · have h_cong : (Nat.choose n m' : ℤ) ≡ CanonicalSumValue n (Nat.choose n m') (by
            assumption) h_not_prime_pow [ZMOD n] := by
              exact lemma_canonical_rep_properties n ( Nat.choose n m' ) ‹_› h_not_prime_pow |>.2
            generalize_proofs at *;
            convert h_cong.symm using 1 ; rw [ Nat.choose_symm ( by linarith ) ];
      · -- By symmetry, $\binom{n}{m} = \binom{n}{m'}$.
        have h_symm : (Nat.choose n m : ℤ) = (Nat.choose n m' : ℤ) := by
          rw [ Nat.choose_symm ( le_of_lt hm_lt_n ) ];
        -- By `lemma_generator_reduction_case_le_half`, there exists a y for m' that satisfies the conditions.
        obtain ⟨y, hy⟩ := lemma_generator_reduction_case_le_half n m' (by
        exact Nat.sub_pos_of_lt hm_lt_n) (by
        exact Nat.sub_lt ( by linarith ) ( by linarith )) h_not_prime_pow h_m'_prime_pow (by
        linarith [ Nat.sub_add_cancel hm_lt_n.le ]);
        grind

/-
Any generator $\binom{n}{m}$ can be reduced to a Prime Power Sum (PPS) that is smaller or equal and congruent modulo $n$.
-/
lemma lemma_generator_reduction (n m : ℕ)
    (hm_ge_1 : 1 ≤ m) (hm_lt_n : m < n)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (h_m_not_prime_pow : ¬ IsPrimePow m) :
    ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ Nat.choose n m ∧ y ≡ Nat.choose n m [ZMOD n] := by
  by_cases h_le_half : 2 * m ≤ n
  · apply lemma_generator_reduction_case_le_half n m hm_ge_1 hm_lt_n h_not_prime_pow h_m_not_prime_pow h_le_half
  · apply lemma_generator_reduction_case_gt_half n m hm_lt_n h_not_prime_pow (by linarith)

/-
Any generator $\binom{n}{m}$ can be reduced to a Prime Power Sum that is smaller or equal and congruent modulo $n$.
-/
lemma lemma_generator_reduction_all (n m : ℕ)
    (hm_ge_1 : 1 ≤ m) (hm_lt_n : m < n)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) :
    ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ Nat.choose n m ∧ y ≡ Nat.choose n m [ZMOD n] := by
      by_cases h_m_prime_pow : IsPrimePow m;
      · by_cases h_gt_half : 2 * m > n;
        · exact
          lemma_generator_reduction_case_gt_half n m hm_lt_n h_not_prime_pow h_gt_half;
        · by_cases h_div : m ∣ n;
          · -- Since $m$ is a prime power and divides $n$, $\binom{n}{m}$ is a Prime Power Sum.
            have h_binom_prime_pow : IsPrimePowerSum n (Nat.choose n m) := by
              obtain ⟨p, k, hp, hk, rfl⟩ : ∃ p k, Nat.Prime p ∧ k ≥ 1 ∧ m = p ^ k := by
                rw [ isPrimePow_nat_iff ] at h_m_prime_pow ; aesop;
              have h_binom_prime_pow : IsPrimePowerSum n (Nat.choose n (p ^ k)) := by
                have h_prime_pow : p ^ k ∣ n := h_div
                have h_not_prime_pow : ∀ q l, Nat.Prime q → n ≠ q ^ l := h_not_prime_pow
                exact (by
                apply lemma_binom_basis_is_pps n p k (by
                exact Nat.mem_primeFactors.mpr ⟨ hp, Nat.dvd_trans ( dvd_pow_self _ ( by linarith ) ) h_prime_pow, by linarith ⟩) (by
                linarith) (by
                have := Nat.factorization_le_iff_dvd ( by aesop ) ( by aesop ) |>.2 h_prime_pow ; aesop));
              exact h_binom_prime_pow;
            exact ⟨ _, h_binom_prime_pow, le_rfl, rfl ⟩;
          · use CanonicalSumValue n (Nat.choose n m) (by linarith) h_not_prime_pow;
            exact ⟨ lemma_canonical_is_pps _ _ ( by linarith ) h_not_prime_pow, lemma_binom_prime_pow_ge_canonical _ _ hm_lt_n ( by linarith ) h_not_prime_pow h_m_prime_pow h_div, lemma_canonical_rep_properties _ _ ( by linarith ) h_not_prime_pow |>.2.symm ⟩;
      · exact lemma_generator_reduction n m hm_ge_1 hm_lt_n h_not_prime_pow h_m_prime_pow

/-
Any generator $\binom{n}{m}$ can be reduced to a Prime Power Sum that is smaller or equal and congruent modulo $n$.
-/
lemma lemma_generator_reduction_combined (n m : ℕ)
    (hm_ge_1 : 1 ≤ m) (hm_lt_n : m < n)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) :
    ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ Nat.choose n m ∧ y ≡ Nat.choose n m [ZMOD n] := by
      convert lemma_generator_reduction_all n m hm_ge_1 hm_lt_n h_not_prime_pow using 1

/-
Any representable integer can be reduced to a Prime Power Sum that is smaller or equal and congruent modulo $n$.
-/
lemma lemma_representable_reduction (n : ℕ) (x : ℤ)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (hx : x ∈ Representable n) :
    ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ x ∧ y ≡ x [ZMOD n] := by
      -- By induction on the structure of `Representable n`.
      have h_induction : ∀ x ∈ Representable n, ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ x ∧ y ≡ x [ZMOD n] := by
        intro x hx
        have h_base : ∀ m ∈ generators_int n, ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ m ∧ y ≡ m [ZMOD n] := by
          intro m hm
          obtain ⟨i, hi⟩ : ∃ i, 1 ≤ i ∧ i < n ∧ m = Nat.choose n i := by
            unfold generators_int at hm; aesop;
          convert lemma_generator_reduction_combined n i hi.1 hi.2.1 h_not_prime_pow using 1 ; aesop ( simp_config := { singlePass := true } ) ;
        have h_zero : ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ 0 ∧ y ≡ 0 [ZMOD n] := by
          exact ⟨ 0, lemma_zero_is_pps n, by norm_num, by norm_num ⟩
        have h_add : ∀ a b : ℤ, (∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ a ∧ y ≡ a [ZMOD n]) → (∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ b ∧ y ≡ b [ZMOD n]) → ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ a + b ∧ y ≡ a + b [ZMOD n] := by
          rintro a b ⟨ y, hy₁, hy₂, hy₃ ⟩ ⟨ z, hz₁, hz₂, hz₃ ⟩ ; exact ⟨ y + z, lemma_sum_is_pps n y z hy₁ hz₁, by linarith, by simpa using hy₃.add hz₃ ⟩ ;
        have h_induction : ∀ x ∈ Representable n, ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ x ∧ y ≡ x [ZMOD n] := by
          intro x hx
          have h_ind : ∀ (xs : List ℤ), (∀ m ∈ xs, ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ m ∧ y ≡ m [ZMOD n]) → ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ List.sum xs ∧ y ≡ List.sum xs [ZMOD n] := by
            intro xs hxs; induction xs <;> aesop;
          obtain ⟨xs, hxs⟩ : ∃ xs : List ℤ, x = List.sum xs ∧ ∀ m ∈ xs, ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ m ∧ y ≡ m [ZMOD n] := by
            have h_induction : ∀ x ∈ Representable n, ∃ xs : List ℤ, x = List.sum xs ∧ ∀ m ∈ xs, ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ m ∧ y ≡ m [ZMOD n] := by
              intro x hx
              have h_ind : ∀ (x : ℤ), x ∈ AddSubmonoid.closure (generators_int n) → ∃ xs : List ℤ, x = List.sum xs ∧ ∀ m ∈ xs, ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ m ∧ y ≡ m [ZMOD n] := by
                intro x hx
                induction' hx using AddSubmonoid.closure_induction with x hx ih
                generalize_proofs at *; (
                exact ⟨ [ x ], by simp +decide, by simpa using h_base x hx ⟩);
                · exact ⟨ [ ], rfl, by intros; contradiction ⟩;
                · rename_i hx hy ih₁ ih₂; obtain ⟨ xs₁, rfl, hx₁ ⟩ := ih₁; obtain ⟨ xs₂, rfl, hx₂ ⟩ := ih₂; exact ⟨ xs₁ ++ xs₂, by simp +decide, fun m hm => by aesop ⟩ ;
              exact h_ind x hx
            generalize_proofs at *; (
            grind)
          generalize_proofs at *; (
          exact hxs.1 ▸ h_ind xs hxs.2 |> fun ⟨ y, hy₁, hy₂, hy₃ ⟩ => ⟨ y, hy₁, by simpa only [ hxs.1 ] using hy₂, by simpa only [ hxs.1 ] using hy₃ ⟩)
        generalize_proofs at *; (
        exact h_induction x hx);
      exact h_induction x hx

/-
If the local sum for prime $p$ is congruent to the target modulo $p^{v_p(n)}$, then it is greater than or equal to the target.
-/
lemma lemma_local_sum_ge_target_explicit (n : ℕ) (c : ℕ → ℕ → ℤ) (p : ℕ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ q k, Nat.Prime q → n ≠ q ^ k)
    (hp : p ∈ n.factorization.support)
    (hc_nonneg : ∀ j ∈ Finset.Icc 1 (n.factorization p), 0 ≤ c p j)
    (h_cong : (∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)) ≡
              (∑ j ∈ Finset.Icc 1 (n.factorization p), (p - 1) * (Nat.choose n (p ^ j) : ℤ)) [ZMOD p ^ (n.factorization p)]) :
    (∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)) ≥
    (∑ j ∈ Finset.Icc 1 (n.factorization p), (p - 1) * (Nat.choose n (p ^ j) : ℤ)) := by
      -- By definition of $A$, we know that $A_j = \binom{n}{p^j}$ for all $j \in \{1, \ldots, n.factorization p\}$.
      set A : ℕ → ℕ := fun j => Nat.choose n (p ^ j) with hA_def;
      have h_super_sequence_induction : IsSuperSequence p (n.factorization p) (fun j => (A j : ℕ)) := by
        apply_rules [ lemma_binom_is_super_sequence ];
      convert lemma_super_sequence_induction _ _ _ _ _ _ _ _ using 1;
      rotate_left;
      exact p;
      exact n.factorization p;
      exact fun j => A j;
      exact fun j => if j ∈ Finset.Icc 1 ( n.factorization p ) then c p j else 0;
      · exact Nat.prime_of_mem_primeFactors hp;
      · exact Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp hp );
      · exact h_super_sequence_induction;
      · aesop;
      · simp_all +decide

set_option maxHeartbeats 0 in
/-
Any Prime Power Sum congruent to $S_{max}$ modulo $n$ is at least $S_{max}$.
-/
lemma lemma_pps_lower_bound (n : ℕ) (y : ℤ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (h_pps : IsPrimePowerSum n y)
    (h_cong : y ≡ S_max n [ZMOD n]) :
    y ≥ S_max n := by
      -- By definition of $IsPrimePowerSum$, there exist coefficients $c_{p,j} \ge 0$ such that $y = \sum_p \sum_j c_{p,j} \binom{n}{p^j}$.
      obtain ⟨c, hc⟩ := h_pps;
      -- For each prime $p$ in the support of $n$, by `lemma_local_congruence_implication`, the local sum $\sum_j c_{p,j} \binom{n}{p^j}$ is congruent to the local target $\sum_j (p-1) \binom{n}{p^j}$ modulo $p^{v_p(n)}$.
      have h_local_congruence : ∀ p ∈ n.factorization.support, (∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)) ≡ (∑ j ∈ Finset.Icc 1 (n.factorization p), (p - 1) * (Nat.choose n (p ^ j) : ℤ)) [ZMOD p ^ (n.factorization p)] := by
        intro p hp
        have h_local_congruence : (∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)) ≡ (∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), (p - 1) * (Nat.choose n (p ^ j) : ℤ)) [ZMOD p ^ (n.factorization p)] := by
          refine' Int.ModEq.of_dvd _ ( hc.2 ▸ h_cong ) |> Int.ModEq.trans <| _;
          · exact_mod_cast Nat.ordProj_dvd _ _;
          · unfold S_max;
            unfold K; simp +decide
            exact congr_arg ( · % _ ) ( Finset.sum_congr rfl fun q hq => by rw [ Finset.sum_mul _ _ _ ] ; exact Finset.sum_congr rfl fun r hr => by rw [ Nat.cast_sub ( Nat.pos_of_mem_primeFactors hq ) ] ; ring );
        have h_local_congruence : ∀ q ∈ n.factorization.support, q ≠ p → (∑ j ∈ Finset.Icc 1 (n.factorization q), c q j * (Nat.choose n (q ^ j) : ℤ)) ≡ 0 [ZMOD p ^ (n.factorization p)] ∧ (∑ j ∈ Finset.Icc 1 (n.factorization q), (q - 1) * (Nat.choose n (q ^ j) : ℤ)) ≡ 0 [ZMOD p ^ (n.factorization p)] := by
          intros q hq hqp
          have h_div : ∀ j ∈ Finset.Icc 1 (n.factorization q), (q ^ j : ℤ) ∣ n → (Nat.choose n (q ^ j) : ℤ) ≡ 0 [ZMOD p ^ (n.factorization p)] := by
            intros j hj hq_div_n
            have h_div : (p ^ (n.factorization p) : ℤ) ∣ (n.choose (q ^ j) : ℤ) := by
              have h_div : (p ^ (n.factorization p) : ℕ) ∣ (n.choose (q ^ j) : ℕ) := by
                have h_div : (p ^ (n.factorization p) : ℕ) ∣ n := by
                  exact Nat.ordProj_dvd _ _
                have h_div_q : ¬(p : ℕ) ∣ q := by
                  intro h; have := Nat.prime_dvd_prime_iff_eq ( Nat.prime_of_mem_primeFactors hp ) ( Nat.prime_of_mem_primeFactors hq ) ; tauto;
                have h_div_q : Nat.gcd (p ^ (n.factorization p)) (q ^ j) = 1 := by
                  exact Nat.Coprime.pow _ _ <| Nat.Prime.coprime_iff_not_dvd ( Nat.prime_of_mem_primeFactors hp ) |>.2 h_div_q;
                have h_div_q : (p ^ (n.factorization p) : ℕ) ∣ (q ^ j) * (n.choose (q ^ j) : ℕ) := by
                  have h_div_q : (p ^ (n.factorization p) : ℕ) ∣ n * (n - 1).choose (q ^ j - 1) := by
                    exact dvd_mul_of_dvd_left h_div _
                  generalize_proofs at *; (
                  cases n <;> cases q <;> simp_all +decide [ Nat.succ_mul_choose_eq ];
                  rw [ Nat.sub_add_cancel ( Nat.one_le_pow _ _ ( Nat.succ_pos _ ) ) ] at h_div_q ; simpa only [ mul_comm ] using h_div_q;)
                generalize_proofs at *; (
                exact ( Nat.Coprime.dvd_of_dvd_mul_left ‹_› h_div_q ) |> fun h => by simpa [ Nat.coprime_comm ] using h;);
              exact_mod_cast h_div;
            exact Int.modEq_zero_iff_dvd.mpr h_div;
          exact ⟨ Int.modEq_zero_iff_dvd.mpr <| Finset.dvd_sum fun j hj => dvd_mul_of_dvd_right ( Int.dvd_of_emod_eq_zero <| h_div j hj <| mod_cast Nat.ordProj_dvd _ _ |> dvd_trans ( pow_dvd_pow _ <| Finset.mem_Icc.mp hj |>.2 ) ) _, Int.modEq_zero_iff_dvd.mpr <| Finset.dvd_sum fun j hj => dvd_mul_of_dvd_right ( Int.dvd_of_emod_eq_zero <| h_div j hj <| mod_cast Nat.ordProj_dvd _ _ |> dvd_trans ( pow_dvd_pow _ <| Finset.mem_Icc.mp hj |>.2 ) ) _ ⟩;
        simp_all +decide [ Int.ModEq ];
        rw [ Finset.sum_eq_add_sum_diff_singleton ( show p ∈ n.primeFactors from by aesop ) ] at *; simp_all +decide [ Int.emod_eq_emod_iff_emod_sub_eq_zero ] ;
        convert dvd_sub ‹ ( p : ℤ ) ^ n.factorization p ∣ ∑ x ∈ n.primeFactors, ∑ j ∈ Finset.Icc 1 ( n.factorization x ), c x j * ↑ ( n.choose ( x ^ j ) ) - ∑ x ∈ n.primeFactors, ∑ j ∈ Finset.Icc 1 ( n.factorization x ), ( ↑x - 1 ) * ↑ ( n.choose ( x ^ j ) ) › ( show ( p : ℤ ) ^ n.factorization p ∣ ∑ x ∈ n.primeFactors \ { p }, ∑ j ∈ Finset.Icc 1 ( n.factorization x ), c x j * ↑ ( n.choose ( x ^ j ) ) - ∑ x ∈ n.primeFactors \ { p }, ∑ j ∈ Finset.Icc 1 ( n.factorization x ), ( ↑x - 1 ) * ↑ ( n.choose ( x ^ j ) ) from ?_ ) using 1 ; simp +decide [ Finset.sum_eq_add_sum_diff_singleton ( show p ∈ n.primeFactors from by aesop ) ] ; ring;
        exact dvd_sub ( Finset.dvd_sum fun q hq => h_local_congruence q ( Nat.prime_of_mem_primeFactors ( Finset.mem_sdiff.mp hq |>.1 ) ) ( Nat.dvd_of_mem_primeFactors ( Finset.mem_sdiff.mp hq |>.1 ) ) ( by aesop ) |>.1 ) ( Finset.dvd_sum fun q hq => h_local_congruence q ( Nat.prime_of_mem_primeFactors ( Finset.mem_sdiff.mp hq |>.1 ) ) ( Nat.dvd_of_mem_primeFactors ( Finset.mem_sdiff.mp hq |>.1 ) ) ( by aesop ) |>.2 );
      -- By `lemma_local_sum_ge_target_explicit`, this implies that the local sum is greater than or equal to the local target.
      have h_local_ge_target : ∀ p ∈ n.factorization.support, (∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ)) ≥ (∑ j ∈ Finset.Icc 1 (n.factorization p), (p - 1) * (Nat.choose n (p ^ j) : ℤ)) := by
        intros p hp
        apply lemma_local_sum_ge_target_explicit n c p hn h_not_prime_pow hp (fun j hj => hc.left p hp j hj) (h_local_congruence p hp);
      -- By summing the inequalities from `h_local_ge_target` over all primes $p$ in the support of $n$, we obtain $y \ge S_{max}(n)$.
      have h_sum_ge_target : ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), c p j * (Nat.choose n (p ^ j) : ℤ) ≥ ∑ p ∈ n.factorization.support, ∑ j ∈ Finset.Icc 1 (n.factorization p), (p - 1) * (Nat.choose n (p ^ j) : ℤ) := by
        exact Finset.sum_le_sum h_local_ge_target;
      convert h_sum_ge_target using 1 ; aesop;
      exact lemma_S_max_def n

/-
The target integer is not representable.
-/
lemma lemma_target_not_representable (n : ℕ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) :
    target n ∉ Representable n := by
      intro h_target;
      obtain ⟨y, hy_pps, hy_le, hy_cong⟩ : ∃ y : ℤ, IsPrimePowerSum n y ∧ y ≤ target n ∧ y ≡ target n [ZMOD n] := by
        apply lemma_representable_reduction n (target n) h_not_prime_pow h_target;
      -- By definition of $target$, we know that $target(n) = S_{max}(n) - n$.
      have h_target_eq : target n = S_max n - n := by
        exact lemma_target_eq_S_max_sub_n n;
      -- By definition of $target$, we know that $y \equiv S_{max}(n) \pmod{n}$.
      have hy_cong_max : y ≡ S_max n [ZMOD n] := by
        simp_all +decide [ Int.ModEq ];
      -- By definition of $target$, we know that $y \ge S_{max}(n)$.
      have hy_ge_max : y ≥ S_max n := by
        apply lemma_pps_lower_bound n y hn h_not_prime_pow hy_pps hy_cong_max;
      linarith [ Nat.pos_of_ne_zero hn ]

/-
Any integer greater than the target is representable.
-/
theorem upper_bound_proven (n : ℕ) (x : ℤ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k)
    (hx : x > target n) :
    x ∈ Representable n := by
      exact upper_bound n x hn h_not_prime_pow hx

/-
The integer `target n` is the largest integer not in `Representable n`.
-/
theorem erdos_435 (n : ℕ)
    (hn : n ≠ 0)
    (h_not_prime_pow : ∀ p k, Nat.Prime p → n ≠ p ^ k) :
    target n ∉ Representable n ∧ ∀ x : ℤ, x > target n → x ∈ Representable n := by
      -- Apply the lemma `lemma_target_not_representable` to conclude the first part of the conjunction.
      apply And.intro (lemma_target_not_representable n hn h_not_prime_pow) (fun x hx => upper_bound_proven n x hn h_not_prime_pow hx)

#print axioms erdos_435
-- 'erdos_435' depends on axioms: [propext, Classical.choice, Quot.sound]
